# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../upgrade.rst:2
msgid "Upgrade guide"
msgstr ""

#: ../../upgrade.rst:4
msgid ""
"This is a companion guide to the :doc:`changelog`. While the changelog "
"briefly lists all of the new features, improvements and bug fixes, this "
"upgrade guide focuses only the subset which directly impacts your "
"experience when upgrading to a new version. But it goes into more detail."
" This includes things like deprecated APIs and their replacements, build "
"system changes, general code modernization and other useful information."
msgstr ""

#: ../../upgrade.rst:14
msgid "v2.9"
msgstr ""

#: ../../upgrade.rst:16
msgid ""
"Any usage of the recently added ``py::make_simple_namespace`` should be "
"converted to using "
"``py::module_::import(\"types\").attr(\"SimpleNamespace\")`` instead."
msgstr ""

#: ../../upgrade.rst:20
msgid ""
"The use of ``_`` in custom type casters can now be replaced with the more"
" readable ``const_name`` instead. The old ``_`` shortcut has been "
"retained unless it is being used as a macro (like for gettext)."
msgstr ""

#: ../../upgrade.rst:28
msgid "v2.7"
msgstr ""

#: ../../upgrade.rst:30
msgid ""
"*Before* v2.7, ``py::str`` can hold ``PyUnicodeObject`` or "
"``PyBytesObject``, and ``py::isinstance<str>()`` is ``true`` for both "
"``py::str`` and ``py::bytes``. Starting with v2.7, ``py::str`` "
"exclusively holds ``PyUnicodeObject`` (`#2409 "
"<https://github.com/pybind/pybind11/pull/2409>`_), and "
"``py::isinstance<str>()`` is ``true`` only for ``py::str``. To help in "
"the transition of user code, the ``PYBIND11_STR_LEGACY_PERMISSIVE`` macro"
" is provided as an escape hatch to go back to the legacy behavior. This "
"macro will be removed in future releases. Two types of required fixes are"
" expected to be common:"
msgstr ""

#: ../../upgrade.rst:40
msgid ""
"Accidental use of ``py::str`` instead of ``py::bytes``, masked by the "
"legacy behavior. These are probably very easy to fix, by changing from "
"``py::str`` to ``py::bytes``."
msgstr ""

#: ../../upgrade.rst:44
msgid ""
"Reliance on py::isinstance<str>(obj) being ``true`` for ``py::bytes``. "
"This is likely to be easy to fix in most cases by adding ``|| "
"py::isinstance<bytes>(obj)``, but a fix may be more involved, e.g. if "
"``py::isinstance<T>`` appears in a template. Such situations will require"
" careful review and custom fixes."
msgstr ""

#: ../../upgrade.rst:54
msgid "v2.6"
msgstr ""

#: ../../upgrade.rst:56
msgid ""
"Usage of the ``PYBIND11_OVERLOAD*`` macros and ``get_overload`` function "
"should be replaced by ``PYBIND11_OVERRIDE*`` and ``get_override``. In the"
" future, the old macros may be deprecated and removed."
msgstr ""

#: ../../upgrade.rst:60
msgid ""
"``py::module`` has been renamed ``py::module_``, but a backward "
"compatible typedef has been included. This change was to avoid a language"
" change in C++20 that requires unqualified ``module`` not be placed at "
"the start of a logical line. Qualified usage is unaffected and the "
"typedef will remain unless the C++ language rules change again."
msgstr ""

#: ../../upgrade.rst:66
msgid ""
"The public constructors of ``py::module_`` have been deprecated. Use "
"``PYBIND11_MODULE`` or ``module_::create_extension_module`` instead."
msgstr ""

#: ../../upgrade.rst:69
msgid ""
"An error is now thrown when ``__init__`` is forgotten on subclasses. This"
" was incorrect before, but was not checked. Add a call to ``__init__`` if"
" it is missing."
msgstr ""

#: ../../upgrade.rst:73
msgid ""
"A ``py::type_error`` is now thrown when casting to a subclass (like "
"``py::bytes`` from ``py::object``) if the conversion is not valid. Make a"
" valid conversion instead."
msgstr ""

#: ../../upgrade.rst:77
msgid ""
"The undocumented ``h.get_type()`` method has been deprecated and replaced"
" by ``py::type::of(h)``."
msgstr ""

#: ../../upgrade.rst:80
msgid ""
"Enums now have a ``__str__`` method pre-defined; if you want to override "
"it, the simplest fix is to add the new ``py::prepend()`` tag when "
"defining ``\"__str__\"``."
msgstr ""

#: ../../upgrade.rst:84
msgid ""
"If ``__eq__`` defined but not ``__hash__``, ``__hash__`` is now set to "
"``None``, as in normal CPython. You should add ``__hash__`` if you "
"intended the class to be hashable, possibly using the new ``py::hash`` "
"shortcut."
msgstr ""

#: ../../upgrade.rst:88
msgid ""
"The constructors for ``py::array`` now always take signed integers for "
"size, for consistency. This may lead to compiler warnings on some "
"systems. Cast to ``py::ssize_t`` instead of ``std::size_t``."
msgstr ""

#: ../../upgrade.rst:92
msgid ""
"The ``tools/clang`` submodule and ``tools/mkdoc.py`` have been moved to a"
" standalone package, `pybind11-mkdoc`_. If you were using those tools, "
"please use them via a pip install from the new location."
msgstr ""

#: ../../upgrade.rst:96
msgid ""
"The ``pybind11`` package on PyPI no longer fills the wheel \"headers\" "
"slot - if you were using the headers from this slot, they are available "
"by requesting the ``global`` extra, that is, ``pip install "
"\"pybind11[global]\"``. (Most users will be unaffected, as the "
"``pybind11/include`` location is reported by ``python -m pybind11 "
"--includes`` and ``pybind11.get_include()`` is still correct and has not "
"changed since 2.5)."
msgstr ""

#: ../../upgrade.rst:106
msgid "CMake support:"
msgstr ""

#: ../../upgrade.rst:108
msgid ""
"The minimum required version of CMake is now 3.4.  Several details of the"
" CMake support have been deprecated; warnings will be shown if you need "
"to change something. The changes are:"
msgstr ""

#: ../../upgrade.rst:112
msgid ""
"``PYBIND11_CPP_STANDARD=<platform-flag>`` is deprecated, please use "
"``CMAKE_CXX_STANDARD=<number>`` instead, or any other valid CMake CXX or "
"CUDA standard selection method, like ``target_compile_features``."
msgstr ""

#: ../../upgrade.rst:116
msgid ""
"If you do not request a standard, pybind11 targets will compile with the "
"compiler default, but not less than C++11, instead of forcing C++14 "
"always. If you depend on the old behavior, please use "
"``set(CMAKE_CXX_STANDARD 14 CACHE STRING \"\")`` instead."
msgstr ""

#: ../../upgrade.rst:121
msgid ""
"Direct ``pybind11::module`` usage should always be accompanied by at "
"least ``set(CMAKE_CXX_VISIBILITY_PRESET hidden)`` or similar - it used to"
" try to manually force this compiler flag (but not correctly on all "
"compilers or with CUDA)."
msgstr ""

#: ../../upgrade.rst:126
msgid ""
"``pybind11_add_module``'s ``SYSTEM`` argument is deprecated and does "
"nothing; linking now behaves like other imported libraries consistently "
"in both config and submodule mode, and behaves like a ``SYSTEM`` library "
"by default."
msgstr ""

#: ../../upgrade.rst:131
msgid ""
"If ``PYTHON_EXECUTABLE`` is not set, virtual environments (``venv``, "
"``virtualenv``, and ``conda``) are prioritized over the standard search "
"(similar to the new FindPython mode)."
msgstr ""

#: ../../upgrade.rst:135
msgid "In addition, the following changes may be of interest:"
msgstr ""

#: ../../upgrade.rst:137
msgid ""
"``CMAKE_INTERPROCEDURAL_OPTIMIZATION`` will be respected by "
"``pybind11_add_module`` if set instead of linking to ``pybind11::lto`` or"
" ``pybind11::thin_lto``."
msgstr ""

#: ../../upgrade.rst:141
msgid ""
"Using ``find_package(Python COMPONENTS Interpreter Development)`` before "
"pybind11 will cause pybind11 to use the new Python mechanisms instead of "
"its own custom search, based on a patched version of classic "
"``FindPythonInterp`` / ``FindPythonLibs``. In the future, this may become"
" the default. A recent (3.15+ or 3.18.2+) version of CMake is "
"recommended."
msgstr ""

#: ../../upgrade.rst:150
msgid "v2.5"
msgstr ""

#: ../../upgrade.rst:152
msgid ""
"The Python package now includes the headers as data in the package "
"itself, as well as in the \"headers\" wheel slot. ``pybind11 --includes``"
" and ``pybind11.get_include()`` report the new location, which is always "
"correct regardless of how pybind11 was installed, making the old "
"``user=`` argument meaningless. If you are not using the function to get "
"the location already, you are encouraged to switch to the package "
"location."
msgstr ""

#: ../../upgrade.rst:161
msgid "v2.2"
msgstr ""

#: ../../upgrade.rst:164
msgid "Deprecation of the ``PYBIND11_PLUGIN`` macro"
msgstr ""

#: ../../upgrade.rst:166
msgid ""
"``PYBIND11_MODULE`` is now the preferred way to create module entry "
"points. The old macro emits a compile-time deprecation warning."
msgstr ""

#: ../../upgrade.rst:189
msgid "New API for defining custom constructors and pickling functions"
msgstr ""

#: ../../upgrade.rst:191
msgid ""
"The old placement-new custom constructors have been deprecated. The new "
"approach uses ``py::init()`` and factory functions to greatly improve "
"type safety."
msgstr ""

#: ../../upgrade.rst:194
msgid ""
"Placement-new can be called accidentally with an incompatible type "
"(without any compiler errors or warnings), or it can initialize the same "
"object multiple times if not careful with the Python-side ``__init__`` "
"calls. The new-style custom constructors prevent such mistakes. See "
":ref:`custom_constructors` for details."
msgstr ""

#: ../../upgrade.rst:215
msgid ""
"Mirroring the custom constructor changes, ``py::pickle()`` is now the "
"preferred way to get and set object state. See :ref:`pickling` for "
"details."
msgstr ""

#: ../../upgrade.rst:244
msgid ""
"For both the constructors and pickling, warnings are shown at module "
"initialization time (on import, not when the functions are called). "
"They're only visible when compiled in debug mode. Sample warning:"
msgstr ""

#: ../../upgrade.rst:255
msgid "Stricter enforcement of hidden symbol visibility for pybind11 modules"
msgstr ""

#: ../../upgrade.rst:257
msgid ""
"pybind11 now tries to actively enforce hidden symbol visibility for "
"modules. If you're using either one of pybind11's :doc:`CMake or Python "
"build systems <compiling>` (the two example repositories) and you haven't"
" been exporting any symbols, there's nothing to be concerned about. All "
"the changes have been done transparently in the background. If you were "
"building manually or relied on specific default visibility, read on."
msgstr ""

#: ../../upgrade.rst:264
msgid ""
"Setting default symbol visibility to *hidden* has always been recommended"
" for pybind11 (see :ref:`faq:symhidden`). On Linux and macOS, hidden "
"symbol visibility (in conjunction with the ``strip`` utility) yields much"
" smaller module binaries. `CPython's extension docs`_ also recommend "
"hiding symbols by default, with the goal of avoiding symbol name clashes "
"between modules. Starting with v2.2, pybind11 enforces this more "
"strictly: (1) by declaring all symbols inside the ``pybind11`` namespace "
"as hidden and (2) by including the ``-fvisibility=hidden`` flag on Linux "
"and macOS (only for extension modules, not for embedding the "
"interpreter)."
msgstr ""

#: ../../upgrade.rst:276
msgid ""
"The namespace-scope hidden visibility is done automatically in pybind11's"
" headers and it's generally transparent to users. It ensures that:"
msgstr ""

#: ../../upgrade.rst:279
msgid ""
"Modules compiled with different pybind11 versions don't clash with each "
"other."
msgstr ""

#: ../../upgrade.rst:281
msgid ""
"Some new features, like ``py::module_local`` bindings, can work as "
"intended."
msgstr ""

#: ../../upgrade.rst:283
msgid ""
"The ``-fvisibility=hidden`` flag applies the same visibility to user "
"bindings outside of the ``pybind11`` namespace. It's now set automatic by"
" pybind11's CMake and Python build systems, but this needs to be done "
"manually by users of other build systems. Adding this flag:"
msgstr ""

#: ../../upgrade.rst:288
msgid ""
"Minimizes the chances of symbol conflicts between modules. E.g. if two "
"unrelated modules were statically linked to different (ABI-incompatible) "
"versions of the same third-party library, a symbol clash would be likely "
"(and would end with unpredictable results)."
msgstr ""

#: ../../upgrade.rst:293
msgid "Produces smaller binaries on Linux and macOS, as pointed out previously."
msgstr ""

#: ../../upgrade.rst:295
msgid ""
"Within pybind11's CMake build system, ``pybind11_add_module`` has always "
"been setting the ``-fvisibility=hidden`` flag in release mode. From now "
"on, it's being applied unconditionally, even in debug mode and it can no "
"longer be opted out of with the ``NO_EXTRAS`` option. The "
"``pybind11::module`` target now also adds this flag to its interface. The"
" ``pybind11::embed`` target is unchanged."
msgstr ""

#: ../../upgrade.rst:301
msgid ""
"The most significant change here is for the ``pybind11::module`` target. "
"If you were previously relying on default visibility, i.e. if your Python"
" module was doubling as a shared library with dependents, you'll need to "
"either export symbols manually (recommended for cross-platform libraries)"
" or factor out the shared library (and have the Python module link to it "
"like the other dependents). As a temporary workaround, you can also "
"restore default visibility using the CMake code below, but this is not "
"recommended in the long run:"
msgstr ""

#: ../../upgrade.rst:319
msgid "Local STL container bindings"
msgstr ""

#: ../../upgrade.rst:321
msgid ""
"Previous pybind11 versions could only bind types globally -- all pybind11"
" modules, even unrelated ones, would have access to the same exported "
"types. However, this would also result in a conflict if two modules "
"exported the same C++ type, which is especially problematic for very "
"common types, e.g. ``std::vector<int>``. :ref:`module_local` were added "
"to resolve this (see that section for a complete usage guide)."
msgstr ""

#: ../../upgrade.rst:328
msgid ""
"``py::class_`` still defaults to global bindings (because these types are"
" usually unique across modules), however in order to avoid clashes of "
"opaque types, ``py::bind_vector`` and ``py::bind_map`` will now bind STL "
"containers as ``py::module_local`` if their elements are: builtins "
"(``int``, ``float``, etc.), not bound using ``py::class_``, or bound as "
"``py::module_local``. For example, this change allows multiple modules to"
" bind ``std::vector<int>`` without causing conflicts. See :ref:`stl_bind`"
" for more details."
msgstr ""

#: ../../upgrade.rst:336
msgid ""
"When upgrading to this version, if you have multiple modules which depend"
" on a single global binding of an STL container, note that all modules "
"can still accept foreign  ``py::module_local`` types in the direction of "
"Python-to-C++. The locality only affects the C++-to-Python direction. If "
"this is needed in multiple modules, you'll need to either:"
msgstr ""

#: ../../upgrade.rst:342
msgid "Add a copy of the same STL binding to all of the modules which need it."
msgstr ""

#: ../../upgrade.rst:344
msgid ""
"Restore the global status of that single binding by marking it "
"``py::module_local(false)``."
msgstr ""

#: ../../upgrade.rst:347
msgid ""
"The latter is an easy workaround, but in the long run it would be best to"
" localize all common type bindings in order to avoid conflicts with "
"third-party modules."
msgstr ""

#: ../../upgrade.rst:353
msgid "Negative strides for Python buffer objects and numpy arrays"
msgstr ""

#: ../../upgrade.rst:355
msgid ""
"Support for negative strides required changing the integer type from "
"unsigned to signed in the interfaces of ``py::buffer_info`` and "
"``py::array``. If you have compiler warnings enabled, you may notice some"
" new conversion warnings after upgrading. These can be resolved using "
"``static_cast``."
msgstr ""

#: ../../upgrade.rst:362
msgid "Deprecation of some ``py::object`` APIs"
msgstr ""

#: ../../upgrade.rst:364
msgid ""
"To compare ``py::object`` instances by pointer, you should now use "
"``obj1.is(obj2)`` which is equivalent to ``obj1 is obj2`` in Python. "
"Previously, pybind11 used ``operator==`` for this (``obj1 == obj2``), but"
" that could be confusing and is now deprecated (so that it can eventually"
" be replaced with proper rich object comparison in a future release)."
msgstr ""

#: ../../upgrade.rst:370
msgid ""
"For classes which inherit from ``py::object``, ``borrowed`` and "
"``stolen`` were previously available as protected constructor tags. Now "
"the types should be used directly instead: ``borrowed_t{}`` and "
"``stolen_t{}`` (`#771 <https://github.com/pybind/pybind11/pull/771>`_)."
msgstr ""

#: ../../upgrade.rst:377
msgid "Stricter compile-time error checking"
msgstr ""

#: ../../upgrade.rst:379
msgid ""
"Some error checks have been moved from run time to compile time. Notably,"
" automatic conversion of ``std::shared_ptr<T>`` is not possible when "
"``T`` is not directly registered with ``py::class_<T>`` (e.g. "
"``std::shared_ptr<int>`` or ``std::shared_ptr<std::vector<T>>`` are not "
"automatically convertible). Attempting to bind a function with such "
"arguments now results in a compile-time error instead of waiting to fail "
"at run time."
msgstr ""

#: ../../upgrade.rst:386
msgid ""
"``py::init<...>()`` constructor definitions are also stricter and now "
"prevent bindings which could cause unexpected behavior:"
msgstr ""

#: ../../upgrade.rst:399
msgid ""
"A non-``const`` lvalue reference is not allowed to bind to an rvalue. "
"However, note that a constructor taking ``const T &`` can still be "
"registered using ``py::init<T>()`` because a ``const`` lvalue reference "
"can bind to an rvalue."
msgstr ""

#: ../../upgrade.rst:404
msgid "v2.1"
msgstr ""

#: ../../upgrade.rst:407
msgid "Minimum compiler versions are enforced at compile time"
msgstr ""

#: ../../upgrade.rst:409
msgid ""
"The minimums also apply to v2.0 but the check is now explicit and a "
"compile-time error is raised if the compiler does not meet the "
"requirements:"
msgstr ""

#: ../../upgrade.rst:412
msgid "GCC >= 4.8"
msgstr ""

#: ../../upgrade.rst:413
msgid "clang >= 3.3 (appleclang >= 5.0)"
msgstr ""

#: ../../upgrade.rst:414
msgid "MSVC >= 2015u3"
msgstr ""

#: ../../upgrade.rst:415
msgid "Intel C++ >= 15.0"
msgstr ""

#: ../../upgrade.rst:419
msgid "The ``py::metaclass`` attribute is not required for static properties"
msgstr ""

#: ../../upgrade.rst:421
msgid ""
"Binding classes with static properties is now possible by default. The "
"zero-parameter version of ``py::metaclass()`` is deprecated. However, a "
"new one-parameter ``py::metaclass(python_type)`` version was added for "
"rare cases when a custom metaclass is needed to override pybind11's "
"default."
msgstr ""

#: ../../upgrade.rst:442
msgid "v2.0"
msgstr ""

#: ../../upgrade.rst:445
msgid "Breaking changes in ``py::class_``"
msgstr ""

#: ../../upgrade.rst:447
msgid ""
"These changes were necessary to make type definitions in pybind11 future-"
"proof, to support PyPy via its ``cpyext`` mechanism (`#527 "
"<https://github.com/pybind/pybind11/pull/527>`_), and to improve "
"efficiency (`rev. 86d825 "
"<https://github.com/pybind/pybind11/commit/86d825>`_)."
msgstr ""

#: ../../upgrade.rst:452
msgid ""
"Declarations of types that provide access via the buffer protocol must "
"now include the ``py::buffer_protocol()`` annotation as an argument to "
"the ``py::class_`` constructor."
msgstr ""

#: ../../upgrade.rst:462
msgid ""
"Classes which include static properties (e.g. ``def_readwrite_static()``)"
" must now include the ``py::metaclass()`` attribute. Note: this "
"requirement has since been removed in v2.1. If you're upgrading from 1.x,"
" it's recommended to skip directly to v2.1 or newer."
msgstr ""

#: ../../upgrade.rst:467
msgid ""
"This version of pybind11 uses a redesigned mechanism for instantiating "
"trampoline classes that are used to override virtual methods from within "
"Python. This led to the following user-visible syntax change:"
msgstr ""

#: ../../upgrade.rst:482
msgid ""
"Importantly, both the original and the trampoline class are now specified"
" as arguments to the ``py::class_`` template, and the ``alias<..>()`` "
"call is gone. The new scheme has zero overhead in cases when Python "
"doesn't override any functions of the underlying C++ class. `rev. 86d825 "
"<https://github.com/pybind/pybind11/commit/86d825>`_."
msgstr ""

#: ../../upgrade.rst:488
msgid ""
"The class type must be the first template argument given to "
"``py::class_`` while the trampoline can be mixed in arbitrary order with "
"other arguments (see the following section)."
msgstr ""

#: ../../upgrade.rst:494
msgid "Deprecation of the ``py::base<T>()`` attribute"
msgstr ""

#: ../../upgrade.rst:496
msgid ""
"``py::base<T>()`` was deprecated in favor of specifying ``T`` as a "
"template argument to ``py::class_``. This new syntax also supports "
"multiple inheritance. Note that, while the type being exported must be "
"the first argument in the ``py::class_<Class, ...>`` template, the order "
"of the following types (bases, holder and/or trampoline) is not "
"important."
msgstr ""

#: ../../upgrade.rst:518
msgid "Out-of-the-box support for ``std::shared_ptr``"
msgstr ""

#: ../../upgrade.rst:520
msgid ""
"The relevant type caster is now built in, so it's no longer necessary to "
"include a declaration of the form:"
msgstr ""

#: ../../upgrade.rst:527
msgid ""
"Continuing to do so won't cause an error or even a deprecation warning, "
"but it's completely redundant."
msgstr ""

#: ../../upgrade.rst:532
msgid "Deprecation of a few ``py::object`` APIs"
msgstr ""

#: ../../upgrade.rst:534
msgid "All of the old-style calls emit deprecation warnings."
msgstr ""

#: ../../upgrade.rst:537
msgid "Old syntax"
msgstr ""

#: ../../upgrade.rst:537
msgid "New syntax"
msgstr ""

#: ../../upgrade.rst:539
msgid "``obj.call(args...)``"
msgstr ""

#: ../../upgrade.rst:539
msgid "``obj(args...)``"
msgstr ""

#: ../../upgrade.rst:541
msgid "``obj.str()``"
msgstr ""

#: ../../upgrade.rst:541
msgid "``py::str(obj)``"
msgstr ""

#: ../../upgrade.rst:543
msgid "``auto l = py::list(obj); l.check()``"
msgstr ""

#: ../../upgrade.rst:543
msgid "``py::isinstance<py::list>(obj)``"
msgstr ""

#: ../../upgrade.rst:545
msgid "``py::object(ptr, true)``"
msgstr ""

#: ../../upgrade.rst:545
msgid "``py::reinterpret_borrow<py::object>(ptr)``"
msgstr ""

#: ../../upgrade.rst:547
msgid "``py::object(ptr, false)``"
msgstr ""

#: ../../upgrade.rst:547
msgid "``py::reinterpret_steal<py::object>(ptr)``"
msgstr ""

#: ../../upgrade.rst:549
msgid "``if (obj.attr(\"foo\"))``"
msgstr ""

#: ../../upgrade.rst:549
msgid "``if (py::hasattr(obj, \"foo\"))``"
msgstr ""

#: ../../upgrade.rst:551
msgid "``if (obj[\"bar\"])``"
msgstr ""

#: ../../upgrade.rst:551
msgid "``if (obj.contains(\"bar\"))``"
msgstr ""

