# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../basics.rst:4
msgid "First steps"
msgstr "第一步"

#: ../../basics.rst:6
msgid ""
"This sections demonstrates the basic features of pybind11. Before getting"
" started, make sure that development environment is set up to compile the"
" included set of test cases."
msgstr ""
"本节演示 pybind11 的基本特性。"
"在开始之前，确保已经设置好开发环境来编译包含的测试用例集。"

#: ../../basics.rst:12
msgid "Compiling the test cases"
msgstr "编译测试用例"

#: ../../basics.rst:15
msgid "Linux/macOS"
msgstr ""

#: ../../basics.rst:17
msgid ""
"On Linux  you'll need to install the **python-dev** or **python3-dev** "
"packages as well as **cmake**. On macOS, the included python version "
"works out of the box, but **cmake** must still be installed."
msgstr ""
"在 Linux 上，你需要安装 **python-dev** 或 **python3-dev** 包以及 **cmake**。"
"在 macOS 上，包含的 python 版本可以开箱即用，但 **cmake** 仍然必须安装。"

#: ../../basics.rst:21
msgid "After installing the prerequisites, run"
msgstr "安装好先决条件后，运行"

#: ../../basics.rst:30
msgid "The last line will both compile and run the tests."
msgstr "最后一行将编译和运行测试。"

#: ../../basics.rst:33
msgid "Windows"
msgstr ""

#: ../../basics.rst:35
msgid "On Windows, only **Visual Studio 2017** and newer are supported."
msgstr "在 Windows 上，只支持 **Visual Studio 2017** 及更新版本。"

#: ../../basics.rst:39
msgid ""
"To use the C++17 in Visual Studio 2017 (MSVC 14.1), pybind11 requires the"
" flag ``/permissive-`` to be passed to the compiler `to enforce standard "
"conformance`_. When building with Visual Studio 2019, this is not "
"strictly necessary, but still advised."
msgstr ""
"要在 Visual Studio 2017 (MSVC 14.1) 中使用 C++ 17, pybind11 要求将 flag ``/permissive-`` 传递给编译器 `to enforce standard conformance`_。"
"在使用 Visual Studio 2019 构建时，这并不是绝对必要的，但仍然建议。"

#: ../../basics.rst:45
msgid "To compile and run the tests:"
msgstr "编译和运行测试："

#: ../../basics.rst:54
msgid ""
"This will create a Visual Studio project, compile and run the target, all"
" from the command line."
msgstr ""
"这将创建 Visual Studio 项目，编译并运行 target，所有这些都来自命令行。"

#: ../../basics.rst:59
msgid ""
"If all tests fail, make sure that the Python binary and the testcases are"
" compiled for the same processor type and bitness (i.e. either **i386** "
"or **x86_64**). You can specify **x86_64** as the target architecture for"
" the generated Visual Studio project using ``cmake -A x64 ..``."
msgstr ""
"如果所有测试都失败，请确保 Python 二进制文件和测试用例被编译为相同的处理器类型和位（即 **i386** 或 **x86_64**）。"
"您可以使用 ``cmake -A x64 ..`` 为生成的 Visual Studio 项目指定 **x86_64** 作为 target 架构。"

#: ../../basics.rst:66
msgid ""
"Advanced users who are already familiar with Boost.Python may want to "
"skip the tutorial and look at the test cases in the :file:`tests` "
"directory, which exercise all features of pybind11."
msgstr ""
"已经熟悉 Boost.Python 的高级用户可能希望跳过本教程，并查看 :file:`tests` 目录中的测试用例，"
"这些用例将测试 pybind11 的所有特性。"

#: ../../basics.rst:71
msgid "Header and namespace conventions"
msgstr "头和名称空间约定"

#: ../../basics.rst:73
msgid ""
"For brevity, all code examples assume that the following two lines are "
"present:"
msgstr ""
"为了简单起见，所有代码示例都假定存在以下两行代码："

#: ../../basics.rst:81
msgid ""
"Some features may require additional headers, but those will be specified"
" as needed."
msgstr ""
"有些功能可能需要额外的 header，但这些将根据需要指定。"

#: ../../basics.rst:86
msgid "Creating bindings for a simple function"
msgstr "为简单函数创建绑定"

#: ../../basics.rst:88
msgid ""
"Let's start by creating Python bindings for an extremely simple function,"
" which adds two numbers and returns their result:"
msgstr ""
"从极其简单的函数创建 Python 绑定开始，该函数将两个数字相加并返回结果："

#: ../../basics.rst:97
msgid ""
"For simplicity [#f1]_, we'll put both this function and the binding code "
"into a file named :file:`example.cpp` with the following contents:"
msgstr ""
"为了简单起见 [#f1]_，将把这个函数和绑定代码放入名为 :file:`example.cpp` 的文件中，内容如下："

#: ../../basics.rst:114
msgid ""
"In practice, implementation and binding code will generally be located in"
" separate files."
msgstr ""
"在实践中，实现和绑定代码通常位于不同的文件中。"

#: ../../basics.rst:117
msgid ""
"The :func:`PYBIND11_MODULE` macro creates a function that will be called "
"when an ``import`` statement is issued from within Python. The module "
"name (``example``) is given as the first macro argument (it should not be"
" in quotes). The second argument (``m``) defines a variable of type "
":class:`py::module_ <module>` which is the main interface for creating "
"bindings. The method :func:`module_::def` generates binding code that "
"exposes the ``add()`` function to Python."
msgstr ""
":func:`PYBIND11_MODULE` 宏创建了一个函数，当 Python 内部发出 ``import`` 语句时将调用该函数。"
"模块名（``example``）作为第一个宏参数给出（它不应该在引号中）。"
"第二个参数（``m``）定义了类型的变量 :class:`py::module_ <module>` ，它是创建绑定的主接口。"
":func:`module_::def` 方法会生成绑定代码，将 ``add()`` 函数公开给 Python。"

#: ../../basics.rst:126
msgid ""
"Notice how little code was needed to expose our function to Python: all "
"details regarding the function's parameters and return value were "
"automatically inferred using template metaprogramming. This overall "
"approach and the used syntax are borrowed from Boost.Python, though the "
"underlying implementation is very different."
msgstr ""
"请注意，将函数公开给 Python 只需要很少的代码：关于函数参数和返回值的所有细节都是使用模板元编程自动推断出来的。"
"这种总体方法和使用的语法借鉴自 Boost.Python，尽管底层实现非常不同。"

#: ../../basics.rst:132
msgid ""
"pybind11 is a header-only library, hence it is not necessary to link "
"against any special libraries and there are no intermediate (magic) "
"translation steps. On Linux, the above example can be compiled using the "
"following command:"
msgstr ""
"pybind11 是只包含头文件的库，因此不需要链接到任何特殊的库，也没有中间（magic）转换步骤。"
"在 Linux 上，上面的例子可以用下面的命令编译："

#: ../../basics.rst:142
msgid ""
"If you used :ref:`include_as_a_submodule` to get the pybind11 source, "
"then use ``$(python3-config --includes) -Iextern/pybind11/include`` "
"instead of ``$(python3 -m pybind11 --includes)`` in the above "
"compilation, as explained in :ref:`building_manually`."
msgstr ""
"如果你使用 :ref:`include_as_a_submodule` 来获取 pybind11 源代码，"
"那么在上述编译中使用 ``$(python3-config --includes) -Iextern/pybind11/include`` 而不是 ``$(python3 -m pybind11 --includes)``，"
"如 :ref:`building_manually` 解释的那样。"

#: ../../basics.rst:147
msgid ""
"For more details on the required compiler flags on Linux and macOS, see "
":ref:`building_manually`. For complete cross-platform compilation "
"instructions, refer to the :ref:`compiling` page."
msgstr ""
"有关 Linux 和 macOS 上所需的编译器标志的详细信息，请参见 :ref:`building_manually`。"
"要获得完整的跨平台编译说明，请参阅 :ref:`compiling` 页面。"

#: ../../basics.rst:151
msgid ""
"The `python_example`_ and `cmake_example`_ repositories are also a good "
"place to start. They are both complete project examples with cross-"
"platform build systems. The only difference between the two is that "
"`python_example`_ uses Python's ``setuptools`` to build the module, while"
" `cmake_example`_ uses CMake (which may be preferable for existing C++ "
"projects)."
msgstr ""
"`python_example`_ 和 `cmake_example`_ 存储库也是很好的入门资料。"
"它们都是跨平台构建系统的完整项目示例。"
"两者之间唯一的区别是 `python_example`_ 使用 Python 的 ``setuptools`` 来构建模块，"
"而 `cmake_example`_  使用 CMake（对于现有的 C++ 项目可能更可取）。"

#: ../../basics.rst:160
msgid ""
"Building the above C++ code will produce a binary module file that can be"
" imported to Python. Assuming that the compiled module is located in the "
"current directory, the following interactive Python session shows how to "
"load and execute the example:"
msgstr ""
"构建上述 C++ 代码将生成可导入 Python 的二进制模块文件。"
"假设编译后的模块位于当前目录中，下面的交互式 Python 会话显示如何加载和执行的示例："

#: ../../basics.rst:179
msgid "Keyword arguments"
msgstr "关键字参数"

#: ../../basics.rst:181
msgid ""
"With a simple code modification, it is possible to inform Python about "
"the names of the arguments (\"i\" and \"j\" in this case)."
msgstr ""
"通过简单的代码修改，就可以通知 Python 参数的名称（在本例中是 \"i\" 和 \"j\"）。"

#: ../../basics.rst:189
msgid ""
":class:`arg` is one of several special tag classes which can be used to "
"pass metadata into :func:`module_::def`. With this modified binding code,"
" we can now call the function using keyword arguments, which is a more "
"readable alternative particularly for functions taking many parameters:"
msgstr ""
":class:`arg` 是几个特殊标记类之一，可用于将元数据传递到 :func:`module_::def`。"
"使用修改后的绑定代码，现在可以使用关键字参数调用函数，这是更可读的替代方法，特别是对于接受多个形参的函数："

#: ../../basics.rst:200
msgid ""
"The keyword names also appear in the function signatures within the "
"documentation."
msgstr ""
"关键字名称也会出现在文档中的函数签名中。"

#: ../../basics.rst:214
msgid "A shorter notation for named arguments is also available:"
msgstr "也可以使用更短的命名参数符号："

#: ../../basics.rst:224
msgid ""
"The :var:`_a` suffix forms a C++11 literal which is equivalent to "
":class:`arg`. Note that the literal operator must first be made visible "
"with the directive ``using namespace pybind11::literals``. This does not "
"bring in anything else from the ``pybind11`` namespace except for "
"literals."
msgstr ""
"后缀 :var:`_a` 形成了 c++ 11 literal，相当于 :class:`arg`。"
"注意，必须首先使用 ``using namespace pybind11::literals`` 使 literal 算子在指令中可见。"
"除了 literal，这不会从 ``pybind11`` 名称空间引入其他任何东西。"

#: ../../basics.rst:232
msgid "Default arguments"
msgstr "默认参数"

#: ../../basics.rst:234
msgid "Suppose now that the function to be bound has default arguments, e.g.:"
msgstr "假设现在要绑定的函数有默认参数，例如："

#: ../../basics.rst:242
msgid ""
"Unfortunately, pybind11 cannot automatically extract these parameters, "
"since they are not part of the function's type information. However, they"
" are simple to specify using an extension of :class:`arg`:"
msgstr ""
"不幸的是，pybind11 不能自动提取这些参数，因为它们不是函数类型信息的一部分。"
"但是，使用 :class:`arg` 的扩展来指定它们很简单："

#: ../../basics.rst:251
msgid "The default values also appear within the documentation."
msgstr "默认值也会出现在文档中。"

#: ../../basics.rst:265
msgid "The shorthand notation is also available for default arguments:"
msgstr "简写符号也可用于默认参数："

#: ../../basics.rst:275
msgid "Exporting variables"
msgstr "导出变量"

#: ../../basics.rst:277
msgid ""
"To expose a value from C++, use the ``attr`` function to register it in a"
" module as shown below. Built-in types and general objects (more on that "
"later) are automatically converted when assigned as attributes, and can "
"be explicitly converted using the function ``py::cast``."
msgstr ""
"要从 C++ 中导出值，使用 ``attr`` 函数将其注册到模块中，如下所示。"
"内置类型和通用对象（稍后会详细介绍）在被赋值为属性时自动转换，并且可以使用函数 ``py::cast`` 显式转换。"

#: ../../basics.rst:290
msgid "These are then accessible from Python:"
msgstr "然后可以从 Python 中访问："

#: ../../basics.rst:303
msgid "Supported data types"
msgstr "支持的数据类型"

#: ../../basics.rst:305
msgid ""
"A large number of data types are supported out of the box and can be used"
" seamlessly as functions arguments, return values or with ``py::cast`` in"
" general. For a full overview, see the :doc:`advanced/cast/index` "
"section."
msgstr ""
"大量的数据类型得到了开箱即用的支持，可以无缝地用作函数参数、返回值或普通使用 ``py::cast``。"
"有关完整的概述，请参阅 :doc:`advanced/cast/index` 一节。"
