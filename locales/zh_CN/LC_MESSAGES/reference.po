# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-29 20:28+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../reference.rst:5
msgid ""
"Please be advised that the reference documentation discussing pybind11 "
"internals is currently incomplete. Please refer to the previous sections "
"and the pybind11 header files for the nitty gritty details."
msgstr ""

#: ../../reference.rst:10
msgid "Reference"
msgstr ""

#: ../../reference.rst:15
msgid "Macros"
msgstr ""

#: ../../<breathe>:1
msgid ""
"This macro creates the entry point that will be invoked when the Python "
"interpreter imports an extension module. The module name is given as the "
"first argument and it should not be in quotes. The second macro argument "
"defines a variable of type `py::module_` which can be used to initialize "
"the module."
msgstr ""

#: ../../<breathe>:1
msgid ""
"The entry point is marked as \"maybe unused\" to aid dead-code detection "
"analysis: since the entry point is typically only looked up at runtime "
"and not referenced during translation, it would otherwise appear as "
"unused (\"dead\") code."
msgstr ""

#: ../../reference.rst:22
msgid "Convenience classes for arbitrary Python types"
msgstr ""

#: ../../reference.rst:25
msgid "Common member functions"
msgstr ""

#: ../../reference.rst
msgid "Public Functions"
msgstr ""

msgid ""
"Return an iterator equivalent to calling iter() in Python. The object "
"must be a collection which supports the iteration protocol."
msgstr ""

msgid ""
"Return an internal functor to invoke the object's sequence protocol. "
"Casting the returned detail::item_accessor instance to a handle or object"
" subclass causes a corresponding call to __getitem__. Assigning a handle "
"or object subclass causes a call to __setitem__."
msgstr ""

msgid ""
"Return an internal functor to access the object's attributes. Casting the"
" returned detail::obj_attr_accessor instance to a handle or object "
"subclass causes a corresponding call to getattr. Assigning a handle or "
"object subclass causes a call to setattr."
msgstr ""

msgid ""
"Matches * unpacking in Python, e.g. to unpack arguments out of a tuple or"
" list for a function call. Applying another * to the result yields ** "
"unpacking, e.g. to unpack a dict as function keyword arguments. See "
"calling_python_functions."
msgstr ""

msgid ""
"Assuming the Python object is a function or implements the __call__ "
"protocol, operator() invokes the underlying function, passing an "
"arbitrary set of parameters. The result is returned as a object and may "
"need to be converted back into a Python object using handle::cast.When "
"some of the arguments cannot be converted to Python objects, the function"
" will throw a cast_error exception. When the Python function call fails, "
"a error_already_set exception is thrown."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Assuming the Python object is a function or implements the ``__call__`` "
"protocol, ``operator()`` invokes the underlying function, passing an "
"arbitrary set of parameters. The result is returned as a `object` and may"
" need to be converted back into a Python object using `handle::cast()`."
msgstr ""

#: ../../<breathe>:1
msgid ""
"When some of the arguments cannot be converted to Python objects, the "
"function will throw a `cast_error` exception. When the Python function "
"call fails, a `error_already_set` exception is thrown."
msgstr ""

#: ../../reference.rst:31
msgid "Without reference counting"
msgstr ""

msgid ""
"Holds a reference to a Python object (no reference counting)The handle "
"class is a thin wrapper around an arbitrary Python object (i.e. a "
"PyObject * in Python's C API). It does not perform any automatic "
"reference counting and merely provides a basic C++ interface to various "
"Python API functions.The object class inherits from handle and adds "
"automatic reference counting features."
msgstr ""

#: ../../<breathe>:1
msgid "Holds a reference to a Python object (no reference counting)"
msgstr ""

#: ../../<breathe>:1
msgid ""
"The `handle` class is a thin wrapper around an arbitrary Python object "
"(i.e. a ``PyObject *`` in Python's C API). It does not perform any "
"automatic reference counting and merely provides a basic C++ interface to"
" various Python API functions."
msgstr ""

#: ../../<breathe>:1
msgid ""
"The `object` class inherits from `handle` and adds automatic reference "
"counting features."
msgstr ""

msgid "Subclassed by args_proxy, kwargs_proxy, object"
msgstr ""

msgid ""
"Manually increase the reference count of the Python object. Usually, it "
"is preferable to use the object class which derives from handle and calls"
" this function automatically. Returns a reference to itself."
msgstr ""

msgid ""
"Manually decrease the reference count of the Python object. Usually, it "
"is preferable to use the object class which derives from handle and calls"
" this function automatically. Returns a reference to itself."
msgstr ""

msgid ""
"Attempt to cast the Python object into the given C++ type. A cast_error "
"will be throw upon failure."
msgstr ""

msgid ""
"Deprecated: Check that the underlying pointers are the same. Equivalent "
"to obj1 is obj2 in Python."
msgstr ""

#: ../../reference.rst:37
msgid "With reference counting"
msgstr ""

msgid ""
"Holds a reference to a Python object (with reference counting)Like "
"handle, the object class is a thin wrapper around an arbitrary Python "
"object (i.e. a PyObject * in Python's C API). In contrast to handle, it "
"optionally increases the object's reference count upon construction, and "
"it always decreases the reference count when the object instance goes out"
" of scope and is destructed. When using object instances consistently, it"
" is much easier to get reference counting right at the first attempt."
msgstr ""

#: ../../<breathe>:1
msgid "Holds a reference to a Python object (with reference counting)"
msgstr ""

#: ../../<breathe>:1
msgid ""
"Like `handle`, the `object` class is a thin wrapper around an arbitrary "
"Python object (i.e. a ``PyObject *`` in Python's C API). In contrast to "
"`handle`, it optionally increases the object's reference count upon "
"construction, and it *always* decreases the reference count when the "
"`object` instance goes out of scope and is destructed. When using "
"`object` instances consistently, it is much easier to get reference "
"counting right at the first attempt."
msgstr ""

msgid ""
"Subclassed by anyset, bool_, buffer, bytearray, bytes, capsule, dict, "
"dtype, ellipsis, exception< type >, float_, function, generic_type, int_,"
" iterable, iterator, list, memoryview, module_, none, sequence, slice, "
"staticmethod, str, tuple, type, weakref"
msgstr ""

msgid ""
"Resets the internal pointer to nullptr without decreasing the object's "
"reference count. The function returns a raw handle to the original Python"
" object."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Declare that a `handle` or ``PyObject *`` is a certain type and borrow "
"the reference. The target type ``T`` must be `object` or one of its "
"derived classes. The function doesn't do any conversions or checks. It's "
"up to the user to make sure that the target type is correct."
msgstr ""

msgid ""
"Like reinterpret_borrow, but steals the reference.PyObject *p = "
"PyObject_Str(obj); py::str s = reinterpret_steal<py::str>(p); // <-- `p` "
"must be already be a `str`"
msgstr ""

#: ../../<breathe>:1
msgid "Like `reinterpret_borrow`, but steals the reference."
msgstr ""

#: ../../reference.rst:47
msgid "Convenience classes for specific Python types"
msgstr ""

msgid "Wrapper for Python extension modules."
msgstr ""

msgid ""
"Create Python binding for a new function within the module scope. Func "
"can be a plain C++ function, a function pointer, or a lambda function. "
"For details on the Extra&& ... extra argument, see section extras."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Create and return a new Python submodule with the given name and "
"docstring. This also works recursively, i.e."
msgstr ""

msgid ""
"Adds an object to the module using the given name.  Throws if an object "
"with the given name already exists.overwrite should almost always be "
"false: attempting to overwrite objects that pybind11 has established "
"will, in most cases, break things."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Adds an object to the module using the given name.  Throws if an object "
"with the given name already exists."
msgstr ""

#: ../../<breathe>:1
msgid ""
"``overwrite`` should almost always be false: attempting to overwrite "
"objects that pybind11 has established will, in most cases, break things."
msgstr ""

#: ../../<breathe>
msgid "Public Static Functions"
msgstr ""

msgid ""
"Create a new top-level module that can be used as the main module of a C "
"extension.def should point to a statically allocated module_def."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Create a new top-level module that can be used as the main module of a C "
"extension."
msgstr ""

#: ../../<breathe>:1
msgid "``def`` should point to a statically allocated module_def."
msgstr ""

#: ../../<breathe> ../../reference.rst
msgid "Functions"
msgstr ""

#: ../../<breathe>:1
msgid ""
"Wraps a Python iterator so that it can also be used as a C++ input "
"iterator"
msgstr ""

#: ../../<breathe>:1
msgid ""
"Caveat: copying an iterator does not (and cannot) clone the internal "
"state of the Python iterable. This also applies to the post-increment "
"operator. This iterator should only be used to retrieve the current value"
" using ``operator*()``."
msgstr ""

#: ../../<breathe>:1
msgid ""
"The value which marks the end of the iteration. ``it == "
"iterator::sentinel()`` is equivalent to catching ``StopIteration`` in "
"Python."
msgstr ""

msgid ""
"Return a string representation of the object. This is analogous to the "
"str() function in Python."
msgstr ""

msgid ""
"Creates memoryview from buffer_info.buffer_info must be created from "
"buffer::request(). Otherwise throws an exception.For creating a "
"memoryview from objects that support buffer protocol, use "
"memoryview(const object& obj) instead of this constructor."
msgstr ""

#: ../../<breathe>:1
msgid "Creates ``memoryview`` from ``buffer_info``."
msgstr ""

#: ../../<breathe>:1
msgid ""
"``buffer_info`` must be created from ``buffer::request()``. Otherwise "
"throws an exception."
msgstr ""

#: ../../<breathe>:1
msgid ""
"For creating a ``memoryview`` from objects that support buffer protocol, "
"use ``memoryview(const object& obj)`` instead of this constructor."
msgstr ""

#: ../../<breathe>:1
msgid "Creates ``memoryview`` from static buffer."
msgstr ""

#: ../../<breathe>:1
msgid ""
"This method is meant for providing a ``memoryview`` for C/C++ buffer not "
"managed by Python. The caller is responsible for managing the lifetime of"
" ``ptr`` and ``format``, which MUST outlive the memoryview constructed "
"here."
msgstr ""

#: ../../<breathe>:1
msgid "See also: Python C API documentation for `PyMemoryView_FromBuffer`_."
msgstr ""

#: ../../<breathe>
msgid "参数"
msgstr ""

#: ../../<breathe>:1
msgid "Pointer to the buffer."
msgstr ""

#: ../../<breathe>:1
msgid "Byte size of an element."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Pointer to the null-terminated format string. For homogeneous Buffers, "
"this should be set to ``format_descriptor<T>::value``."
msgstr ""

#: ../../<breathe>:1
msgid "Shape of the tensor (1 entry per dimension)."
msgstr ""

#: ../../<breathe>:1
msgid "Number of bytes between adjacent entries (for each per dimension)."
msgstr ""

#: ../../<breathe>:1
msgid "Flag to indicate if the underlying storage may be written to."
msgstr ""

msgid ""
"Creates memoryview from static memory.This method is meant for providing "
"a memoryview for C/C++ buffer not managed by Python. The caller is "
"responsible for managing the lifetime of mem, which MUST outlive the "
"memoryview constructed here.See also: Python C API documentation for "
"PyMemoryView_FromBuffer."
msgstr ""

#: ../../<breathe>:1
msgid "Creates ``memoryview`` from static memory."
msgstr ""

#: ../../<breathe>:1
msgid ""
"This method is meant for providing a ``memoryview`` for C/C++ buffer not "
"managed by Python. The caller is responsible for managing the lifetime of"
" ``mem``, which MUST outlive the memoryview constructed here."
msgstr ""

#: ../../reference.rst:56
msgid "Convenience functions converting to Python types"
msgstr ""

#: ../../reference.rst:72
msgid "Passing extra arguments to ``def`` or ``class_``"
msgstr ""

#: ../../<breathe>:1
msgid ""
"A call policy which places one or more guard variables (``Ts...``) around"
" the function call."
msgstr ""

#: ../../<breathe>:1
msgid "For example, this definition:"
msgstr ""

#: ../../<breathe>:1
msgid "is equivalent to the following pseudocode:"
msgstr ""

#: ../../reference.rst
msgid "Public Members"
msgstr ""

#: ../../reference.rst:78
msgid "Embedding the interpreter"
msgstr ""

#: ../../<breathe>:1
msgid ""
"Add a new module to the table of builtins for the interpreter. Must be "
"defined in global scope. The first macro parameter is the name of the "
"module (without quotes). The second parameter is the variable which will "
"be used as the interface to add functions and classes to the module."
msgstr ""

msgid ""
"Initialize the Python interpreter. No other pybind11 or CPython API "
"functions can be called before this is done; with the exception of "
"PYBIND11_EMBEDDED_MODULE. The optional init_signal_handlers parameter can"
" be used to skip the registration of signal handlers (see the Python "
"documentation for details). Calling this function again after the "
"interpreter has already been initialized is a fatal error.If initializing"
" the Python interpreter fails, then the program is terminated.  (This is "
"controlled by the CPython runtime and is an exception to pybind11's "
"normal behavior of throwing exceptions on errors.)The remaining optional "
"parameters, argc, argv, and add_program_dir_to_path are used to populate "
"sys.argv and sys.path. See the PySys_SetArgvEx documentation for "
"details./media/pc/data/lxw/ai/pybind11/docs/reference.rst:1: (INFO/1) No "
"directive entry for \"replace\" in module "
"\"docutils.parsers.rst.languages.zh_cn\". Using English fallback for "
"directive \"replace\".PySys_SetArgvEx documentation"
msgstr ""

#: ../../<breathe>:1
msgid ""
"Initialize the Python interpreter. No other pybind11 or CPython API "
"functions can be called before this is done; with the exception of "
"`PYBIND11_EMBEDDED_MODULE`. The optional `init_signal_handlers` parameter"
" can be used to skip the registration of signal handlers (see the `Python"
" documentation`_ for details). Calling this function again after the "
"interpreter has already been initialized is a fatal error."
msgstr ""

#: ../../<breathe>:1
msgid ""
"If initializing the Python interpreter fails, then the program is "
"terminated.  (This is controlled by the CPython runtime and is an "
"exception to pybind11's normal behavior of throwing exceptions on "
"errors.)"
msgstr ""

#: ../../<breathe>:1
msgid ""
"The remaining optional parameters, `argc`, `argv`, and "
"`add_program_dir_to_path` are used to populate ``sys.argv`` and "
"``sys.path``. See the |PySys_SetArgvEx documentation|_ for details."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Shut down the Python interpreter. No pybind11 or CPython API functions "
"can be called after this. In addition, pybind11 objects must not outlive "
"the interpreter:"
msgstr ""

#: ../../<breathe>:1
msgid ""
"The interpreter can be restarted by calling `initialize_interpreter` "
"again. Modules created using pybind11 can be safely re-initialized. "
"However, Python itself cannot completely unload binary extension modules "
"and there are several caveats with regard to interpreter restarting. All "
"the details can be found in the CPython documentation. In short, not all "
"interpreter memory may be freed, either due to reference cycles or user-"
"created global data."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Scope guard version of `initialize_interpreter` and "
"`finalize_interpreter`. This a move-only guard and only a single instance"
" can exist."
msgstr ""

#: ../../<breathe>:1
msgid ""
"See `initialize_interpreter` for a discussion of its constructor "
"arguments."
msgstr ""

#: ../../reference.rst:89
msgid "Redirecting C++ streams"
msgstr ""

#: ../../<breathe>:1
msgid "This a move-only guard that redirects output."
msgstr ""

#: ../../<breathe>:1
msgid ""
"You can explicitly pass the c++ stream and the python object, for example"
" to guard stderr instead."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Like `scoped_ostream_redirect`, but redirects cerr by default. This class"
" is provided primary to make ``py::call_guard`` easier to make."
msgstr ""

#: ../../<breathe>:1
msgid ""
"This is a helper function to add a C++ redirect context manager to Python"
" instead of using a C++ guard. To use it, add the following to your "
"binding code:"
msgstr ""

#: ../../<breathe>:1
msgid "You now have a Python context manager that redirects your output:"
msgstr ""

#: ../../<breathe>:1
msgid "This manager can optionally be told which streams to operate on:"
msgstr ""

#: ../../reference.rst:98
msgid "Python built-in functions"
msgstr ""

msgid ""
"Return true if obj is an instance of T. Type T must be a subclass of "
"object or a class which was exposed to Python as py::class_<T>."
msgstr ""

#: ../../reference.rst:104
msgid "Inheritance"
msgstr ""

#: ../../reference.rst:106
msgid "See :doc:`/classes` and :doc:`/advanced/classes` for more detail."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Macro to populate the virtual method in the trampoline class. This macro "
"tries to look up the method from the Python side, deals with the "
":ref:`gil` and necessary argument conversions to call this method and "
"return the appropriate type. This macro should be used if the method name"
" in C and in Python are identical. See :ref:`overriding_virtuals` for "
"more information."
msgstr ""

msgid ""
"Macro for pure virtual functions, this function is identical to "
"PYBIND11_OVERRIDE, except that it throws if no override can be found."
msgstr ""

#: ../../<breathe>:1
msgid ""
"Macro to populate the virtual method in the trampoline class. This macro "
"tries to look up a method named 'fn' from the Python side, deals with the"
" :ref:`gil` and necessary argument conversions to call this method and "
"return the appropriate type. See :ref:`overriding_virtuals` for more "
"information. This macro should be used when the method name in C is not "
"the same as the method name in Python. For example with `__str__`."
msgstr ""

msgid ""
"Macro for pure virtual functions, this function is identical to "
"PYBIND11_OVERRIDE_NAME, except that it throws if no override can be "
"found."
msgstr ""

#: ../../<breathe>
msgid "this_ptr"
msgstr ""

#: ../../<breathe>:1
msgid ""
"The pointer to the object the overridden method should be retrieved for. "
"This should be the first non-trampoline class encountered in the "
"inheritance chain."
msgstr ""

#: ../../<breathe>
msgid "name"
msgstr ""

#: ../../<breathe>:1
msgid "The name of the overridden Python method to retrieve."
msgstr ""

#: ../../reference.rst
msgid "返回"
msgstr ""

#: ../../<breathe>:1
msgid ""
"The Python method by this name from the object or an empty function "
"wrapper."
msgstr ""

#: ../../reference.rst:119
msgid "Exceptions"
msgstr ""

#: ../../reference.rst:128
msgid "Literals"
msgstr ""

#~ msgid ""
#~ "This macro creates the entry point "
#~ "that will be invoked when the "
#~ "Python interpreter imports an extension "
#~ "module. The module name is given "
#~ "as the fist argument and it should"
#~ " not be in quotes. The second "
#~ "macro argument defines a variable of "
#~ "type `py::module_` which can be used "
#~ "to initialize the module."
#~ msgstr ""

#~ msgid ""
#~ "Initialize the Python interpreter. No "
#~ "other pybind11 or CPython API functions"
#~ " can be called before this is "
#~ "done; with the exception of "
#~ "PYBIND11_EMBEDDED_MODULE. The optional "
#~ "init_signal_handlers parameter can be used "
#~ "to skip the registration of signal "
#~ "handlers (see the Python documentation "
#~ "for details). Calling this function "
#~ "again after the interpreter has already"
#~ " been initialized is a fatal error.If"
#~ " initializing the Python interpreter fails,"
#~ " then the program is terminated.  "
#~ "(This is controlled by the CPython "
#~ "runtime and is an exception to "
#~ "pybind11's normal behavior of throwing "
#~ "exceptions on errors.)The remaining optional"
#~ " parameters, argc, argv, and "
#~ "add_program_dir_to_path are used to populate"
#~ " sys.argv and sys.path. See the "
#~ "PySys_SetArgvEx documentation for "
#~ "details./media/pc/data/4tb/lxw/books/pybind11/docs/reference.rst:1:"
#~ " (INFO/1) No directive entry for "
#~ "\"replace\" in module "
#~ "\"docutils.parsers.rst.languages.zh_cn\". Using English"
#~ " fallback for directive "
#~ "\"replace\".PySys_SetArgvEx documentation"
#~ msgstr ""

