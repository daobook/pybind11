# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../faq.rst:2
msgid "Frequently asked questions"
msgstr ""

#: ../../faq.rst:5
msgid "\"ImportError: dynamic module does not define init function\""
msgstr ""

#: ../../faq.rst:7
msgid ""
"1. Make sure that the name specified in PYBIND11_MODULE is identical to "
"the filename of the extension library (without suffixes such as ``.so``)."
msgstr ""

#: ../../faq.rst:10
msgid ""
"2. If the above did not fix the issue, you are likely using an "
"incompatible version of Python that does not match what you compiled "
"with."
msgstr ""

#: ../../faq.rst:14
msgid "\"Symbol not found: ``__Py_ZeroStruct`` / ``_PyInstanceMethod_Type``\""
msgstr ""

#: ../../faq.rst:16 ../../faq.rst:21 ../../faq.rst:26
msgid "See the first answer."
msgstr ""

#: ../../faq.rst:19
msgid "\"SystemError: dynamic module not initialized properly\""
msgstr ""

#: ../../faq.rst:24
msgid "The Python interpreter immediately crashes when importing my module"
msgstr ""

#: ../../faq.rst:31
msgid "Limitations involving reference arguments"
msgstr ""

#: ../../faq.rst:33
msgid ""
"In C++, it's fairly common to pass arguments using mutable references or "
"mutable pointers, which allows both read and write access to the value "
"supplied by the caller. This is sometimes done for efficiency reasons, or"
" to realize functions that have multiple return values. Here are two very"
" basic examples:"
msgstr ""

#: ../../faq.rst:44
msgid ""
"In Python, all arguments are passed by reference, so there is no general "
"issue in binding such code from Python."
msgstr ""

#: ../../faq.rst:47
msgid ""
"However, certain basic Python types (like ``str``, ``int``, ``bool``, "
"``float``, etc.) are **immutable**. This means that the following attempt"
" to port the function to Python doesn't have the same effect on the value"
" provided by the caller -- in fact, it does nothing at all."
msgstr ""

#: ../../faq.rst:57
msgid ""
"pybind11 is also affected by such language-level conventions, which means"
" that binding ``increment`` or ``increment_ptr`` will also create Python "
"functions that don't modify their arguments."
msgstr ""

#: ../../faq.rst:61
msgid ""
"Although inconvenient, one workaround is to encapsulate the immutable "
"types in a custom type that does allow modifications."
msgstr ""

#: ../../faq.rst:64
msgid ""
"An other alternative involves binding a small wrapper lambda function "
"that returns a tuple with all output arguments (see the remainder of the "
"documentation for examples on binding lambda functions). An example:"
msgstr ""

#: ../../faq.rst:72
msgid "and the binding code"
msgstr ""

#: ../../faq.rst:80
msgid "How can I reduce the build time?"
msgstr ""

#: ../../faq.rst:82
msgid ""
"It's good practice to split binding code over multiple files, as in the "
"following example:"
msgstr ""

#: ../../faq.rst:85
msgid ":file:`example.cpp`:"
msgstr ""

#: ../../faq.rst:99
msgid ":file:`ex1.cpp`:"
msgstr ""

#: ../../faq.rst:107
msgid ":file:`ex2.cpp`:"
msgstr ""

#: ../../faq.rst:115
msgid ":command:`python`:"
msgstr ""

#: ../../faq.rst:125
msgid ""
"As shown above, the various ``init_ex`` functions should be contained in "
"separate files that can be compiled independently from one another, and "
"then linked together into the same final shared object.  Following this "
"approach will:"
msgstr ""

#: ../../faq.rst:130
msgid "reduce memory requirements per compilation unit."
msgstr ""

#: ../../faq.rst:132
msgid "enable parallel builds (if desired)."
msgstr ""

#: ../../faq.rst:134
msgid ""
"allow for faster incremental builds. For instance, when a single class "
"definition is changed, only a subset of the binding code will generally "
"need to be recompiled."
msgstr ""

#: ../../faq.rst:139
msgid "\"recursive template instantiation exceeded maximum depth of 256\""
msgstr ""

#: ../../faq.rst:141
msgid ""
"If you receive an error about excessive recursive template evaluation, "
"try specifying a larger value, e.g. ``-ftemplate-depth=1024`` on "
"GCC/Clang. The culprit is generally the generation of function signatures"
" at compile time using C++14 template metaprogramming."
msgstr ""

#: ../../faq.rst:149
msgid ""
"\"'SomeClass' declared with greater visibility than the type of its field"
" 'SomeClass::member' [-Wattributes]\""
msgstr ""

#: ../../faq.rst:151
msgid ""
"This error typically indicates that you are compiling without the "
"required ``-fvisibility`` flag.  pybind11 code internally forces hidden "
"visibility on all internal code, but if non-hidden (and thus *exported*) "
"code attempts to include a pybind type (for example, ``py::object`` or "
"``py::list``) you can run into this warning."
msgstr ""

#: ../../faq.rst:157
msgid ""
"To avoid it, make sure you are specifying ``-fvisibility=hidden`` when "
"compiling pybind code."
msgstr ""

#: ../../faq.rst:160
msgid ""
"As to why ``-fvisibility=hidden`` is necessary, because pybind modules "
"could have been compiled under different versions of pybind itself, it is"
" also important that the symbols defined in one module do not clash with "
"the potentially-incompatible symbols defined in another.  While Python "
"extension modules are usually loaded with localized symbols (under POSIX "
"systems typically using ``dlopen`` with the ``RTLD_LOCAL`` flag), this "
"Python default can be changed, but even if it isn't it is not always "
"enough to guarantee complete independence of the symbols involved when "
"not using ``-fvisibility=hidden``."
msgstr ""

#: ../../faq.rst:170
msgid ""
"Additionally, ``-fvisibility=hidden`` can deliver considerably binary "
"size savings. (See the following section for more details.)"
msgstr ""

#: ../../faq.rst:177
msgid "How can I create smaller binaries?"
msgstr ""

#: ../../faq.rst:179
msgid ""
"To do its job, pybind11 extensively relies on a programming technique "
"known as *template metaprogramming*, which is a way of performing "
"computation at compile time using type information. Template "
"metaprogramming usually instantiates code involving significant numbers "
"of deeply nested types that are either completely removed or reduced to "
"just a few instructions during the compiler's optimization phase. "
"However, due to the nested nature of these types, the resulting symbol "
"names in the compiled extension library can be extremely long. For "
"instance, the included test suite contains the following symbol:"
msgstr ""

#: ../../faq.rst:200
msgid "which is the mangled form of the following function type:"
msgstr ""

#: ../../faq.rst:206
msgid ""
"The memory needed to store just the mangled name of this function (196 "
"bytes) is larger than the actual piece of code (111 bytes) it represents!"
" On the other hand, it's silly to even give this function a name -- after"
" all, it's just a tiny cog in a bigger piece of machinery that is not "
"exposed to the outside world. So we'll generally only want to export "
"symbols for those functions which are actually called from the outside."
msgstr ""

#: ../../faq.rst:213
msgid ""
"This can be achieved by specifying the parameter ``-fvisibility=hidden`` "
"to GCC and Clang, which sets the default symbol visibility to *hidden*, "
"which has a tremendous impact on the final binary size of the resulting "
"extension library. (On Visual Studio, symbols are already hidden by "
"default, so nothing needs to be done there.)"
msgstr ""

#: ../../faq.rst:219
msgid ""
"In addition to decreasing binary size, ``-fvisibility=hidden`` also "
"avoids potential serious issues when loading multiple modules and is "
"required for proper pybind operation.  See the previous FAQ entry for "
"more details."
msgstr ""

#: ../../faq.rst:224
msgid "How can I properly handle Ctrl-C in long-running functions?"
msgstr ""

#: ../../faq.rst:226
msgid ""
"Ctrl-C is received by the Python interpreter, and holds it until the GIL "
"is released, so a long-running function won't be interrupted."
msgstr ""

#: ../../faq.rst:229
msgid ""
"To interrupt from inside your function, you can use the "
"``PyErr_CheckSignals()`` function, that will tell if a signal has been "
"raised on the Python side.  This function merely checks a flag, so its "
"impact is negligible. When a signal has been received, you must either "
"explicitly interrupt execution by throwing ``py::error_already_set`` "
"(which will propagate the existing ``KeyboardInterrupt``), or clear the "
"error (which you usually will not want):"
msgstr ""

#: ../../faq.rst:251
msgid "CMake doesn't detect the right Python version"
msgstr ""

#: ../../faq.rst:253
msgid ""
"The CMake-based build system will try to automatically detect the "
"installed version of Python and link against that. When this fails, or "
"when there are multiple versions of Python and it finds the wrong one, "
"delete ``CMakeCache.txt`` and then add ``-DPYTHON_EXECUTABLE=$(which "
"python)`` to your CMake configure line. (Replace ``$(which python)`` with"
" a path to python if your prefer.)"
msgstr ""

#: ../../faq.rst:260
msgid ""
"You can alternatively try ``-DPYBIND11_FINDPYTHON=ON``, which will "
"activate the new CMake FindPython support instead of pybind11's custom "
"search. Requires CMake 3.12+, and 3.15+ or 3.18.2+ are even better. You "
"can set this in your ``CMakeLists.txt`` before adding or finding "
"pybind11, as well."
msgstr ""

#: ../../faq.rst:266
msgid "Inconsistent detection of Python version in CMake and pybind11"
msgstr ""

#: ../../faq.rst:268
msgid ""
"The functions ``find_package(PythonInterp)`` and "
"``find_package(PythonLibs)`` provided by CMake for Python version "
"detection are modified by pybind11 due to unreliability and limitations "
"that make them unsuitable for pybind11's needs. Instead pybind11 provides"
" its own, more reliable Python detection CMake code. Conflicts can arise,"
" however, when using pybind11 in a project that *also* uses the CMake "
"Python detection in a system with several Python versions installed."
msgstr ""

#: ../../faq.rst:275
msgid ""
"This difference may cause inconsistencies and errors if *both* mechanisms"
" are used in the same project."
msgstr ""

#: ../../faq.rst:278
msgid "There are three possible solutions:"
msgstr ""

#: ../../faq.rst:280
msgid ""
"Avoid using ``find_package(PythonInterp)`` and "
"``find_package(PythonLibs)`` from CMake and rely on pybind11 in detecting"
" Python version. If this is not possible, the CMake machinery should be "
"called *before* including pybind11."
msgstr ""

#: ../../faq.rst:283
msgid ""
"Set ``PYBIND11_FINDPYTHON`` to ``True`` or use ``find_package(Python "
"COMPONENTS Interpreter Development)`` on modern CMake (3.12+, 3.15+ "
"better, 3.18.2+ best). Pybind11 in these cases uses the new CMake "
"FindPython instead of the old, deprecated search tools, and these modules"
" are much better at finding the correct Python."
msgstr ""

#: ../../faq.rst:288
msgid ""
"Set ``PYBIND11_NOPYTHON`` to ``TRUE``. Pybind11 will not search for "
"Python. However, you will have to use the target-based system, and do "
"more setup yourself, because it does not know about or include things "
"that depend on Python, like ``pybind11_add_module``. This might be ideal "
"for integrating into an existing system, like scikit-build's Python "
"helpers."
msgstr ""

#: ../../faq.rst:295
msgid "How to cite this project?"
msgstr ""

#: ../../faq.rst:297
msgid ""
"We suggest the following BibTeX template to cite pybind11 in scientific "
"discourse:"
msgstr ""

