# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../advanced/exceptions.rst:2
msgid "Exceptions"
msgstr ""

#: ../../advanced/exceptions.rst:5
msgid "Built-in C++ to Python exception translation"
msgstr ""

#: ../../advanced/exceptions.rst:7
msgid ""
"When Python calls C++ code through pybind11, pybind11 provides a C++ "
"exception handler that will trap C++ exceptions, translate them to the "
"corresponding Python exception, and raise them so that Python code can "
"handle them."
msgstr ""

#: ../../advanced/exceptions.rst:11
msgid ""
"pybind11 defines translations for ``std::exception`` and its standard "
"subclasses, and several special exception classes that translate to "
"specific Python exceptions. Note that these are not actually Python "
"exceptions, so they cannot be examined using the Python C API. Instead, "
"they are pure C++ objects that pybind11 will translate the corresponding "
"Python exception when they arrive at its exception handler."
msgstr ""

#: ../../advanced/exceptions.rst:21
msgid "Exception thrown by C++"
msgstr ""

#: ../../advanced/exceptions.rst:21
msgid "Translated to Python exception type"
msgstr ""

#: ../../advanced/exceptions.rst:23
msgid ":class:`std::exception`"
msgstr ""

#: ../../advanced/exceptions.rst:23 ../../advanced/exceptions.rst:63
msgid "``RuntimeError``"
msgstr ""

#: ../../advanced/exceptions.rst:25
msgid ":class:`std::bad_alloc`"
msgstr ""

#: ../../advanced/exceptions.rst:25
msgid "``MemoryError``"
msgstr ""

#: ../../advanced/exceptions.rst:27
msgid ":class:`std::domain_error`"
msgstr ""

#: ../../advanced/exceptions.rst:27 ../../advanced/exceptions.rst:29
#: ../../advanced/exceptions.rst:31 ../../advanced/exceptions.rst:35
msgid "``ValueError``"
msgstr ""

#: ../../advanced/exceptions.rst:29
msgid ":class:`std::invalid_argument`"
msgstr ""

#: ../../advanced/exceptions.rst:31
msgid ":class:`std::length_error`"
msgstr ""

#: ../../advanced/exceptions.rst:33
msgid ":class:`std::out_of_range`"
msgstr ""

#: ../../advanced/exceptions.rst:33
msgid "``IndexError``"
msgstr ""

#: ../../advanced/exceptions.rst:35
msgid ":class:`std::range_error`"
msgstr ""

#: ../../advanced/exceptions.rst:37
msgid ":class:`std::overflow_error`"
msgstr ""

#: ../../advanced/exceptions.rst:37
msgid "``OverflowError``"
msgstr ""

#: ../../advanced/exceptions.rst:39
msgid ":class:`pybind11::stop_iteration`"
msgstr ""

#: ../../advanced/exceptions.rst:39
msgid "``StopIteration`` (used to implement custom iterators)"
msgstr ""

#: ../../advanced/exceptions.rst:42
msgid ":class:`pybind11::index_error`"
msgstr ""

#: ../../advanced/exceptions.rst:42
msgid ""
"``IndexError`` (used to indicate out of bounds access in ``__getitem__``,"
" ``__setitem__``, etc.)"
msgstr ""

#: ../../advanced/exceptions.rst:46
msgid ":class:`pybind11::key_error`"
msgstr ""

#: ../../advanced/exceptions.rst:46
msgid ""
"``KeyError`` (used to indicate out of bounds access in ``__getitem__``, "
"``__setitem__`` in dict-like objects, etc.)"
msgstr ""

#: ../../advanced/exceptions.rst:51
msgid ":class:`pybind11::value_error`"
msgstr ""

#: ../../advanced/exceptions.rst:51
msgid ""
"``ValueError`` (used to indicate wrong value passed in "
"``container.remove(...)``)"
msgstr ""

#: ../../advanced/exceptions.rst:55
msgid ":class:`pybind11::type_error`"
msgstr ""

#: ../../advanced/exceptions.rst:55
msgid "``TypeError``"
msgstr ""

#: ../../advanced/exceptions.rst:57
msgid ":class:`pybind11::buffer_error`"
msgstr ""

#: ../../advanced/exceptions.rst:57
msgid "``BufferError``"
msgstr ""

#: ../../advanced/exceptions.rst:59
msgid ":class:`pybind11::import_error`"
msgstr ""

#: ../../advanced/exceptions.rst:59
msgid "``ImportError``"
msgstr ""

#: ../../advanced/exceptions.rst:61
msgid ":class:`pybind11::attribute_error`"
msgstr ""

#: ../../advanced/exceptions.rst:61
msgid "``AttributeError``"
msgstr ""

#: ../../advanced/exceptions.rst:63
msgid "Any other exception"
msgstr ""

#: ../../advanced/exceptions.rst:66
msgid ""
"Exception translation is not bidirectional. That is, *catching* the C++ "
"exceptions defined above will not trap exceptions that originate from "
"Python. For that, catch :class:`pybind11::error_already_set`. See "
":ref:`below <handling_python_exceptions_cpp>` for further details."
msgstr ""

#: ../../advanced/exceptions.rst:71
msgid ""
"There is also a special exception :class:`cast_error` that is thrown by "
":func:`handle::call` when the input arguments cannot be converted to "
"Python objects."
msgstr ""

#: ../../advanced/exceptions.rst:76
msgid "Registering custom translators"
msgstr ""

#: ../../advanced/exceptions.rst:78
msgid ""
"If the default exception conversion policy described above is "
"insufficient, pybind11 also provides support for registering custom "
"exception translators. Similar to pybind11 classes, exception translators"
" can be local to the module they are defined in or global to the entire "
"python session.  To register a simple exception conversion that "
"translates a C++ exception into a new Python exception using the C++ "
"exception's ``what()`` method, a helper function is available:"
msgstr ""

#: ../../advanced/exceptions.rst:89
msgid ""
"This call creates a Python exception class with the name ``PyExp`` in the"
" given module and automatically converts any encountered exceptions of "
"type ``CppExp`` into Python exceptions of type ``PyExp``."
msgstr ""

#: ../../advanced/exceptions.rst:93
msgid ""
"A matching function is available for registering a local exception "
"translator:"
msgstr ""

#: ../../advanced/exceptions.rst:100
msgid ""
"It is possible to specify base class for the exception using the third "
"parameter, a ``handle``:"
msgstr ""

#: ../../advanced/exceptions.rst:108
msgid "Then ``PyExp`` can be caught both as ``PyExp`` and ``RuntimeError``."
msgstr ""

#: ../../advanced/exceptions.rst:110
msgid ""
"The class objects of the built-in Python exceptions are listed in the "
"Python documentation on `Standard Exceptions "
"<https://docs.python.org/3/c-api/exceptions.html#standard-exceptions>`_. "
"The default base class is ``PyExc_Exception``."
msgstr ""

#: ../../advanced/exceptions.rst:114
msgid ""
"When more advanced exception translation is needed, the functions "
"``py::register_exception_translator(translator)`` and "
"``py::register_local_exception_translator(translator)`` can be used to "
"register functions that can translate arbitrary exception types (and "
"which may include additional logic to do so).  The functions takes a "
"stateless callable (e.g. a function pointer or a lambda function without "
"captured variables) with the call signature ``void(std::exception_ptr)``."
msgstr ""

#: ../../advanced/exceptions.rst:122
msgid ""
"When a C++ exception is thrown, the registered exception translators are "
"tried in reverse order of registration (i.e. the last registered "
"translator gets the first shot at handling the exception). All local "
"translators will be tried before a global translator is tried."
msgstr ""

#: ../../advanced/exceptions.rst:127
msgid ""
"Inside the translator, ``std::rethrow_exception`` should be used within a"
" try block to re-throw the exception.  One or more catch clauses to catch"
" the appropriate exceptions should then be used with each clause using "
"``PyErr_SetString`` to set a Python exception or ``ex(string)`` to set "
"the python exception to a custom exception type (see below)."
msgstr ""

#: ../../advanced/exceptions.rst:133
msgid ""
"To declare a custom Python exception type, declare a ``py::exception`` "
"variable and use this in the associated exception translator (note: it is"
" often useful to make this a static declaration when using it inside a "
"lambda expression without requiring capturing)."
msgstr ""

#: ../../advanced/exceptions.rst:138
msgid ""
"The following example demonstrates this for a hypothetical exception "
"classes ``MyCustomException`` and ``OtherException``: the first is "
"translated to a custom python exception ``MyCustomError``, while the "
"second is translated to a standard python RuntimeError:"
msgstr ""

#: ../../advanced/exceptions.rst:156
msgid ""
"Multiple exceptions can be handled by a single translator, as shown in "
"the example above. If the exception is not caught by the current "
"translator, the previously registered one gets a chance."
msgstr ""

#: ../../advanced/exceptions.rst:160
msgid ""
"If none of the registered exception translators is able to handle the "
"exception, it is handled by the default converter as described in the "
"previous section."
msgstr ""

#: ../../advanced/exceptions.rst:166
msgid ""
"The file :file:`tests/test_exceptions.cpp` contains examples of various "
"custom exception translators and custom exception types."
msgstr ""

#: ../../advanced/exceptions.rst:171
msgid ""
"Call either ``PyErr_SetString`` or a custom exception's call operator "
"(``exc(string)``) for every exception caught in a custom exception "
"translator.  Failure to do so will cause Python to crash with "
"``SystemError: error return without exception set``."
msgstr ""

#: ../../advanced/exceptions.rst:176
msgid ""
"Exceptions that you do not plan to handle should simply not be caught, or"
" may be explicitly (re-)thrown to delegate it to the other, previously-"
"declared existing exception translators."
msgstr ""

#: ../../advanced/exceptions.rst:180
msgid ""
"Note that ``libc++`` and ``libstdc++`` `behave differently "
"<https://stackoverflow.com/questions/19496643/using-clang-fvisibility-"
"hidden-and-typeinfo-and-type-erasure/28827430>`_ with "
"``-fvisibility=hidden``. Therefore exceptions that are used across ABI "
"boundaries need to be explicitly exported, as exercised in "
"``tests/test_exceptions.h``. See also: \"Problems with C++ exceptions\" "
"under `GCC Wiki <https://gcc.gnu.org/wiki/Visibility>`_."
msgstr ""

#: ../../advanced/exceptions.rst:186
msgid "Local vs Global Exception Translators"
msgstr ""

#: ../../advanced/exceptions.rst:188
msgid ""
"When a global exception translator is registered, it will be applied "
"across all modules in the reverse order of registration. This can create "
"behavior where the order of module import influences how exceptions are "
"translated."
msgstr ""

#: ../../advanced/exceptions.rst:192
msgid "If module1 has the following translator:"
msgstr ""

#: ../../advanced/exceptions.rst:204
msgid "and module2 has the following similar translator:"
msgstr ""

#: ../../advanced/exceptions.rst:216
msgid ""
"then which translator handles the invalid_argument will be determined by "
"the order that module1 and module2 are imported. Since exception "
"translators are applied in the reverse order of registration, which ever "
"module was imported last will \"win\" and that translator will be "
"applied."
msgstr ""

#: ../../advanced/exceptions.rst:221
msgid ""
"If there are multiple pybind11 modules that share exception types (either"
" standard built-in or custom) loaded into a single python instance and "
"consistent error handling behavior is needed, then local translators "
"should be used."
msgstr ""

#: ../../advanced/exceptions.rst:226
msgid ""
"Changing the previous example to use "
"``register_local_exception_translator`` would mean that when "
"invalid_argument is thrown in the module2 code, the module2 translator "
"will always handle it, while in module1, the module1 translator will do "
"the same."
msgstr ""

#: ../../advanced/exceptions.rst:234
msgid "Handling exceptions from Python in C++"
msgstr ""

#: ../../advanced/exceptions.rst:236
msgid ""
"When C++ calls Python functions, such as in a callback function or when "
"manipulating Python objects, and Python raises an ``Exception``, pybind11"
" converts the Python exception into a C++ exception of type "
":class:`pybind11::error_already_set` whose payload contains a C++ string "
"textual summary and the actual Python exception. ``error_already_set`` is"
" used to propagate Python exception back to Python (or possibly, handle "
"them in C++)."
msgstr ""

#: ../../advanced/exceptions.rst:246
msgid "Exception raised in Python"
msgstr ""

#: ../../advanced/exceptions.rst:246
msgid "Thrown as C++ exception type"
msgstr ""

#: ../../advanced/exceptions.rst:248
msgid "Any Python ``Exception``"
msgstr ""

#: ../../advanced/exceptions.rst:248
msgid ":class:`pybind11::error_already_set`"
msgstr ""

#: ../../advanced/exceptions.rst:251
msgid "For example:"
msgstr ""

#: ../../advanced/exceptions.rst:270
msgid ""
"Note that C++ to Python exception translation does not apply here, since "
"that is a method for translating C++ exceptions to Python, not vice "
"versa. The error raised from Python is always ``error_already_set``."
msgstr ""

#: ../../advanced/exceptions.rst:274
msgid "This example illustrates this behavior:"
msgstr ""

#: ../../advanced/exceptions.rst:302
msgid "Handling errors from the Python C API"
msgstr ""

#: ../../advanced/exceptions.rst:304
msgid ""
"Where possible, use :ref:`pybind11 wrappers <wrappers>` instead of "
"calling the Python C API directly. When calling the Python C API "
"directly, in addition to manually managing reference counts, one must "
"follow the pybind11 error protocol, which is outlined here."
msgstr ""

#: ../../advanced/exceptions.rst:309
msgid ""
"After calling the Python C API, if Python returns an error, ``throw "
"py::error_already_set();``, which allows pybind11 to deal with the "
"exception and pass it back to the Python interpreter. This includes calls"
" to the error setting functions such as ``PyErr_SetString``."
msgstr ""

#: ../../advanced/exceptions.rst:322
msgid ""
"Alternately, to ignore the error, call `PyErr_Clear "
"<https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Clear>`_."
msgstr ""

#: ../../advanced/exceptions.rst:325
msgid ""
"Any Python error must be thrown or cleared, or Python/pybind11 will be "
"left in an invalid state."
msgstr ""

#: ../../advanced/exceptions.rst:329
msgid "Chaining exceptions ('raise from')"
msgstr ""

#: ../../advanced/exceptions.rst:331
msgid ""
"Python has a mechanism for indicating that exceptions were caused by "
"other exceptions:"
msgstr ""

#: ../../advanced/exceptions.rst:341
msgid ""
"To do a similar thing in pybind11, you can use the ``py::raise_from`` "
"function. It sets the current python error indicator, so to continue "
"propagating the exception you should ``throw py::error_already_set()``."
msgstr ""

#: ../../advanced/exceptions.rst:359
msgid "Handling unraisable exceptions"
msgstr ""

#: ../../advanced/exceptions.rst:361
msgid ""
"If a Python function invoked from a C++ destructor or any function marked"
" ``noexcept(true)`` (collectively, \"noexcept functions\") throws an "
"exception, there is no way to propagate the exception, as such functions "
"may not throw. Should they throw or fail to catch any exceptions in their"
" call graph, the C++ runtime calls ``std::terminate()`` to abort "
"immediately."
msgstr ""

#: ../../advanced/exceptions.rst:367
msgid ""
"Similarly, Python exceptions raised in a class's ``__del__`` method do "
"not propagate, but are logged by Python as an unraisable error. In Python"
" 3.8+, a `system hook is triggered "
"<https://docs.python.org/3/library/sys.html#sys.unraisablehook>`_ and an "
"auditing event is logged."
msgstr ""

#: ../../advanced/exceptions.rst:373
msgid ""
"Any noexcept function should have a try-catch block that traps "
"class:`error_already_set` (or any other exception that can occur). Note "
"that pybind11 wrappers around Python exceptions such as "
":class:`pybind11::value_error` are *not* Python exceptions; they are C++ "
"exceptions that pybind11 catches and converts to Python exceptions. "
"Noexcept functions cannot propagate these exceptions either. A useful "
"approach is to convert them to Python exceptions and then "
"``discard_as_unraisable`` as shown below."
msgstr ""

