# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../advanced/pycpp/numpy.rst:4
msgid "NumPy"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:7
msgid "Buffer protocol"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:9
msgid ""
"Python supports an extremely general and convenient approach for "
"exchanging data between plugin libraries. Types can expose a buffer view "
"[#f2]_, which provides fast direct access to the raw internal data "
"representation. Suppose we want to bind the following simplistic Matrix "
"class:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:29
msgid ""
"The following binding code exposes the ``Matrix`` contents as a buffer "
"object, making it possible to cast Matrices into NumPy arrays. It is even"
" possible to completely avoid copy operations with Python expressions "
"like ``np.array(matrix_instance, copy = False)``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:49
msgid ""
"Supporting the buffer protocol in a new type involves specifying the "
"special ``py::buffer_protocol()`` tag in the ``py::class_`` constructor "
"and calling the ``def_buffer()`` method with a lambda function that "
"creates a ``py::buffer_info`` description record on demand describing a "
"given matrix instance. The contents of ``py::buffer_info`` mirror the "
"Python buffer protocol specification."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:67
msgid ""
"To create a C++ function that can take a Python buffer object as an "
"argument, simply use the type ``py::buffer`` as one of its arguments. "
"Buffers can exist in a great variety of configurations, hence some safety"
" checks are usually necessary in the function body. Below, you can see a "
"basic example on how to define a custom constructor for the Eigen double "
"precision matrix (``Eigen::MatrixXd``) type, which supports "
"initialization from compatible buffer objects (e.g. a NumPy matrix)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:107
msgid ""
"For reference, the ``def_buffer()`` call for this Eigen data type should "
"look as follows:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:125
msgid ""
"For a much easier approach of binding Eigen types (although with some "
"limitations), refer to the section on :doc:`/advanced/cast/eigen`."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:130
msgid ""
"The file :file:`tests/test_buffers.cpp` contains a complete example that "
"demonstrates using the buffer protocol with pybind11 in more detail."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:133
msgid "http://docs.python.org/3/c-api/buffer.html"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:136
msgid "Arrays"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:138
msgid ""
"By exchanging ``py::buffer`` with ``py::array`` in the above snippet, we "
"can restrict the function so that it only accepts NumPy arrays (rather "
"than any type of Python object satisfying the buffer protocol)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:142
msgid ""
"In many situations, we want to define a function which only accepts a "
"NumPy array of a certain data type. This is possible via the "
"``py::array_t<T>`` template. For instance, the following function "
"requires the argument to be a NumPy array containing double precision "
"values."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:151
msgid ""
"When it is invoked with a different type (e.g. an integer or a list of "
"integers), the binding code will attempt to cast the input into a NumPy "
"array of the requested type. This feature requires the "
":file:`pybind11/numpy.h` header to be included. Note that "
":file:`pybind11/numpy.h` does not depend on the NumPy headers, and thus "
"can be used without declaring a build-time dependency on NumPy; "
"NumPy>=1.7.0 is a runtime dependency."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:158
msgid ""
"Data in NumPy arrays is not guaranteed to packed in a dense manner; "
"furthermore, entries can be separated by arbitrary column and row "
"strides. Sometimes, it can be useful to require a function to only accept"
" dense arrays using either the C (row-major) or Fortran (column-major) "
"ordering. This can be accomplished via a second template argument with "
"values ``py::array::c_style`` or ``py::array::f_style``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:169
msgid ""
"The ``py::array::forcecast`` argument is the default value of the second "
"template parameter, and it ensures that non-conforming arguments are "
"converted into an array satisfying the specified requirements instead of "
"trying the next function overload."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:174
msgid ""
"There are several methods on arrays; the methods listed below under "
"references work, as well as the following functions based on the NumPy "
"API:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:177
msgid "``.dtype()`` returns the type of the contained values."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:179
msgid ""
"``.strides()`` returns a pointer to the strides of the array (optionally "
"pass an integer axis to get a number)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:182
msgid ""
"``.flags()`` returns the flag settings. ``.writable()`` and "
"``.owndata()`` are directly available."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:185
msgid "``.offset_at()`` returns the offset (optionally pass indices)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:187
msgid "``.squeeze()`` returns a view with length-1 axes removed."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:189
msgid "``.view(dtype)`` returns a view of the array with a different dtype."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:191
msgid ""
"``.reshape({i, j, ...})`` returns a view of the array with a different "
"shape. ``.resize({...})`` is also available."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:194
msgid ""
"``.index_at(i, j, ...)`` gets the count from the beginning to a given "
"index."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:197
msgid "There are also several methods for getting references (described below)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:200
msgid "Structured types"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:202
msgid ""
"In order for ``py::array_t`` to work with structured (record) types, we "
"first need to register the memory layout of the type. This can be done "
"via ``PYBIND11_NUMPY_DTYPE`` macro, called in the plugin definition code,"
" which expects the type followed by field names:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:228
msgid ""
"The structure should consist of fundamental arithmetic types, "
"``std::complex``, previously registered substructures, and arrays of any "
"of the above. Both C++ arrays and ``std::array`` are supported. While "
"there is a static assertion to prevent many types of unsupported "
"structures, it is still the user's responsibility to use only \"plain\" "
"structures that can be safely manipulated as raw memory without violating"
" invariants."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:236
msgid "Vectorizing functions"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:238
msgid ""
"Suppose we want to bind a function with the following signature to Python"
" so that it can process arbitrary NumPy array arguments (vectors, "
"matrices, general N-D arrays) in addition to its normal arguments:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:246
msgid "After including the ``pybind11/numpy.h`` header, this is extremely simple:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:252
msgid ""
"Invoking the function like below causes 4 calls to be made to ``my_func``"
" with each of the array elements. The significant advantage of this "
"compared to solutions like ``numpy.vectorize()`` is that the loop over "
"the elements runs entirely on the C++ side and can be crunched down into "
"a tight, optimized loop by the compiler. The result is returned as a "
"NumPy array of type ``numpy.dtype.float64``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:266
msgid ""
"The scalar argument ``z`` is transparently replicated 4 times.  The input"
" arrays ``x`` and ``y`` are automatically converted into the right types "
"(they are of type  ``numpy.dtype.int64`` but need to be "
"``numpy.dtype.int32`` and ``numpy.dtype.float32``, respectively)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:273
msgid ""
"Only arithmetic, complex, and POD types passed by value or by ``const &``"
" reference are vectorized; all other arguments are passed through as-is. "
"Functions taking rvalue reference arguments cannot be vectorized."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:277
msgid ""
"In cases where the computation is too complicated to be reduced to "
"``vectorize``, it will be necessary to create and access the buffer "
"contents manually. The following snippet contains a complete example that"
" shows how this works (the code is somewhat contrived, since it could "
"have been done more simply using ``vectorize``)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:320
msgid ""
"The file :file:`tests/test_numpy_vectorize.cpp` contains a complete "
"example that demonstrates using :func:`vectorize` in more detail."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:324
msgid "Direct access"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:326
msgid ""
"For performance reasons, particularly when dealing with very large "
"arrays, it is often desirable to directly access array elements without "
"internal checking of dimensions and bounds on every access when indices "
"are known to be already valid.  To avoid such checks, the ``array`` class"
" and ``array_t<T>`` template class offer an unchecked proxy object that "
"can be used for this unchecked access through the ``unchecked<N>`` and "
"``mutable_unchecked<N>`` methods, where ``N`` gives the required "
"dimensionality of the array:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:353
msgid ""
"To obtain the proxy from an ``array`` object, you must specify both the "
"data type and number of dimensions as template arguments, such as ``auto "
"r = myarray.mutable_unchecked<float, 2>()``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:357
msgid ""
"If the number of dimensions is not known at compile time, you can omit "
"the dimensions template parameter (i.e. calling ``arr_t.unchecked()`` or "
"``arr.unchecked<T>()``.  This will give you a proxy object that works in "
"the same way, but results in less optimizable code and thus a small "
"efficiency loss in tight loops."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:363
msgid ""
"Note that the returned proxy object directly references the array's data,"
" and only reads its shape, strides, and writeable flag when constructed."
"  You must take care to ensure that the referenced array is not destroyed"
" or reshaped for the duration of the returned object, typically by "
"limiting the scope of the returned instance."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:369
msgid ""
"The returned proxy object supports some of the same methods as "
"``py::array`` so that it can be used as a drop-in replacement for some "
"existing, index-checked uses of ``py::array``:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:373
msgid "``.ndim()`` returns the number of dimensions"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:375
msgid ""
"``.data(1, 2, ...)`` and ``r.mutable_data(1, 2, ...)``` returns a pointer"
" to the ``const T`` or ``T`` data, respectively, at the given indices.  "
"The latter is only available to proxies obtained via "
"``a.mutable_unchecked()``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:379
msgid "``.itemsize()`` returns the size of an item in bytes, i.e. ``sizeof(T)``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:381
msgid "``.ndim()`` returns the number of dimensions."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:383
msgid "``.shape(n)`` returns the size of dimension ``n``"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:385
msgid ""
"``.size()`` returns the total number of elements (i.e. the product of the"
" shapes)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:387
msgid ""
"``.nbytes()`` returns the number of bytes used by the referenced elements"
" (i.e. ``itemsize()`` times ``size()``)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:392
msgid ""
"The file :file:`tests/test_numpy_array.cpp` contains additional examples "
"demonstrating the use of this feature."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:396
msgid "Ellipsis"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:398
msgid ""
"Python provides a convenient ``...`` ellipsis notation that is often used"
" to slice multidimensional arrays. For instance, the following snippet "
"extracts the middle dimensions of a tensor with the first and last index "
"set to zero."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:407
msgid ""
"The function ``py::ellipsis()`` function can be used to perform the same "
"operation on the C++ side:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:417
msgid "Memory view"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:419
msgid ""
"For a case when we simply want to provide a direct accessor to C/C++ "
"buffer without a concrete class object, we can return a ``memoryview`` "
"object. Suppose we wish to expose a ``memoryview`` for 2x4 uint8_t array,"
" we can do the following:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:438
msgid ""
"This approach is meant for providing a ``memoryview`` for a C/C++ buffer "
"not managed by Python. The user is responsible for managing the lifetime "
"of the buffer. Using a ``memoryview`` created in this way after deleting "
"the buffer in C++ side results in undefined behavior."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:443
msgid ""
"We can also use ``memoryview::from_memory`` for a simple 1D contiguous "
"buffer:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:454
msgid "``memoryview::from_memory`` added."
msgstr ""

