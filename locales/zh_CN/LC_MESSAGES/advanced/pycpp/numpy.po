# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../advanced/pycpp/numpy.rst:4
msgid "NumPy"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:7
msgid "Buffer protocol"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:9
msgid ""
"Python supports an extremely general and convenient approach for "
"exchanging data between plugin libraries. Types can expose a buffer view "
"[#f2]_, which provides fast direct access to the raw internal data "
"representation. Suppose we want to bind the following simplistic Matrix "
"class:"
msgstr ""
"Python 支持非常通用和方便的方法来在插件库之间交换数据。"
"类型可以公开 buffer视图 [#f2]_，它提供对原始内部数据表示形式的快速直接访问。"
"假设想要绑定以下简单的 Matrix 类："

#: ../../advanced/pycpp/numpy.rst:29
msgid ""
"The following binding code exposes the ``Matrix`` contents as a buffer "
"object, making it possible to cast Matrices into NumPy arrays. It is even"
" possible to completely avoid copy operations with Python expressions "
"like ``np.array(matrix_instance, copy = False)``."
msgstr ""
"下面的绑定代码将 ``Matrix`` 内容公开为 buffer 对象，使得将 Matrices 转换为 NumPy 数组成为可能。"
"甚至可以完全避免使用 Python 表达式 ``np.array(matrix_instance, copy = False)`` 进行复制运算。"

#: ../../advanced/pycpp/numpy.rst:49
msgid ""
"Supporting the buffer protocol in a new type involves specifying the "
"special ``py::buffer_protocol()`` tag in the ``py::class_`` constructor "
"and calling the ``def_buffer()`` method with a lambda function that "
"creates a ``py::buffer_info`` description record on demand describing a "
"given matrix instance. The contents of ``py::buffer_info`` mirror the "
"Python buffer protocol specification."
msgstr ""
"在新类型中支持 buffer protocol 需要在 ``py::class_`` 构造函数中指定特殊的 ``py::buffer_protocol()``  tag，"
"并使用 lambda 函数调用 ``def_buffer()`` 方法，该方法根据需要创建 ``py::buffer_info`` 描述记录，"
"描述给定的矩阵实例。``py::buffer_info`` 的内容反映了 Python buffer protocol 规范。"

#: ../../advanced/pycpp/numpy.rst:67
msgid ""
"To create a C++ function that can take a Python buffer object as an "
"argument, simply use the type ``py::buffer`` as one of its arguments. "
"Buffers can exist in a great variety of configurations, hence some safety"
" checks are usually necessary in the function body. Below, you can see a "
"basic example on how to define a custom constructor for the Eigen double "
"precision matrix (``Eigen::MatrixXd``) type, which supports "
"initialization from compatible buffer objects (e.g. a NumPy matrix)."
msgstr ""
"要创建可以接受 Python buffer 对象作为参数的 C++ 函数，只需使用 ``py::buffer`` 类型作为它的参数之一。"
"Buffer 可以存在于各种各样的配置中，因此在函数体中通常需要进行一些安全检查。"
"下面，你可以看到基本的例子，关于如何为 Eigen 双精度矩阵（``Eigen::MatrixXd``）类型定义自定义构造函数，"
"它支持从兼容的 buffer 对象（例如 NumPy matrix）初始化。"

#: ../../advanced/pycpp/numpy.rst:107
msgid ""
"For reference, the ``def_buffer()`` call for this Eigen data type should "
"look as follows:"
msgstr ""
"为了引用，这个 Eigen 数据类型的 ``def_buffer()`` 调用应该如下所示："

#: ../../advanced/pycpp/numpy.rst:125
msgid ""
"For a much easier approach of binding Eigen types (although with some "
"limitations), refer to the section on :doc:`/advanced/cast/eigen`."
msgstr ""
"对于绑定 Eigen 类型（尽管有一些限制）的更简单的方法,请参阅 :doc:`/advanced/cast/eigen` 的章节。"

#: ../../advanced/pycpp/numpy.rst:130
msgid ""
"The file :file:`tests/test_buffers.cpp` contains a complete example that "
"demonstrates using the buffer protocol with pybind11 in more detail."
msgstr ""
"文件 :file:`tests/test_buffers.cpp` 包含完整的示例，它更详细地演示了使用 pybind11 的 buffer protocol。"

#: ../../advanced/pycpp/numpy.rst:133
msgid "http://docs.python.org/3/c-api/buffer.html"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:136
msgid "Arrays"
msgstr "数组"

#: ../../advanced/pycpp/numpy.rst:138
msgid ""
"By exchanging ``py::buffer`` with ``py::array`` in the above snippet, we "
"can restrict the function so that it only accepts NumPy arrays (rather "
"than any type of Python object satisfying the buffer protocol)."
msgstr ""
"在上面的代码片段中，通过将 ``py::buffer`` 与 ``py::array`` 互换，"
"可以限制该函数，使其只接受 NumPy 数组（而不是任何满足 buffer protocol 的 Python 对象类型）。"

#: ../../advanced/pycpp/numpy.rst:142
msgid ""
"In many situations, we want to define a function which only accepts a "
"NumPy array of a certain data type. This is possible via the "
"``py::array_t<T>`` template. For instance, the following function "
"requires the argument to be a NumPy array containing double precision "
"values."
msgstr ""
"在许多情况下,希望定义函数,它只接受某个数据类型的 NumPy 数组。"
"这可能要借助 ``py::array_t<T>`` 模板。"
"例如，下面的函数要求参数成为包含双精度值的 NumPy 数组。"

#: ../../advanced/pycpp/numpy.rst:151
msgid ""
"When it is invoked with a different type (e.g. an integer or a list of "
"integers), the binding code will attempt to cast the input into a NumPy "
"array of the requested type. This feature requires the "
":file:`pybind11/numpy.h` header to be included. Note that "
":file:`pybind11/numpy.h` does not depend on the NumPy headers, and thus "
"can be used without declaring a build-time dependency on NumPy; "
"NumPy>=1.7.0 is a runtime dependency."
msgstr ""
"当它以不同的类型（例如整数或整数列表）调用时，"
"绑定代码将尝试将 input 输入到请求类型的 NumPy 数组中。"
"这个特性需要包含 :file:`pybind11/numpy.h`。"
"注意 :file:`pybind11/numpy.h` 不依赖于 NumPy 头，因此可以在没有声明 NumPy 的构建时依赖的情况下使用；"
"NumPy>=1.7.0 是运行时依赖。"

#: ../../advanced/pycpp/numpy.rst:158
msgid ""
"Data in NumPy arrays is not guaranteed to packed in a dense manner; "
"furthermore, entries can be separated by arbitrary column and row "
"strides. Sometimes, it can be useful to require a function to only accept"
" dense arrays using either the C (row-major) or Fortran (column-major) "
"ordering. This can be accomplished via a second template argument with "
"values ``py::array::c_style`` or ``py::array::f_style``."
msgstr ""
"在 NumPy 数组中数据不保证以密集的方式填充；此外，条目可以由任意的列和行大步分离。"
"有时，要求函数只接受密集数组（使用 C（行为主）或 Fortran（列为主）排序）会很有用。"
"这可以通过第二个模板参数 ``py::array::c_style`` 或 ``py::array::f_style`` 来完成。"

#: ../../advanced/pycpp/numpy.rst:169
msgid ""
"The ``py::array::forcecast`` argument is the default value of the second "
"template parameter, and it ensures that non-conforming arguments are "
"converted into an array satisfying the specified requirements instead of "
"trying the next function overload."
msgstr ""
"``py::array::forcecast`` 参数是第二个模板形参的默认值，"
"它确保不符合要求的参数被转换为满足指定要求的数组，而不是尝试下一次函数重载。"

#: ../../advanced/pycpp/numpy.rst:174
msgid ""
"There are several methods on arrays; the methods listed below under "
"references work, as well as the following functions based on the NumPy "
"API:"
msgstr ""
"数组有几种方法；引用下面列出的方法可以工作，以及以下基于 NumPy API 的函数："

#: ../../advanced/pycpp/numpy.rst:177
msgid "``.dtype()`` returns the type of the contained values."
msgstr "``.dtype()`` 返回所包含值的类型。"

#: ../../advanced/pycpp/numpy.rst:179
msgid ""
"``.strides()`` returns a pointer to the strides of the array (optionally "
"pass an integer axis to get a number)."
msgstr ""
"``.strides()`` 返回指向数组步长的指针（可以选择传递整数轴来获得数字）。"

#: ../../advanced/pycpp/numpy.rst:182
msgid ""
"``.flags()`` returns the flag settings. ``.writable()`` and "
"``.owndata()`` are directly available."
msgstr ""
"``.flags()`` 返回标志设置。``.writable()`` 和 ``.owndata()`` 是直接可用的。"

#: ../../advanced/pycpp/numpy.rst:185
msgid "``.offset_at()`` returns the offset (optionally pass indices)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:187
msgid "``.squeeze()`` returns a view with length-1 axes removed."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:189
msgid "``.view(dtype)`` returns a view of the array with a different dtype."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:191
msgid ""
"``.reshape({i, j, ...})`` returns a view of the array with a different "
"shape. ``.resize({...})`` is also available."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:194
msgid ""
"``.index_at(i, j, ...)`` gets the count from the beginning to a given "
"index."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:197
msgid "There are also several methods for getting references (described below)."
msgstr "还有几种获取引用的方法（如下所述）。"

#: ../../advanced/pycpp/numpy.rst:200
msgid "Structured types"
msgstr "结构化类型"

#: ../../advanced/pycpp/numpy.rst:202
msgid ""
"In order for ``py::array_t`` to work with structured (record) types, we "
"first need to register the memory layout of the type. This can be done "
"via ``PYBIND11_NUMPY_DTYPE`` macro, called in the plugin definition code,"
" which expects the type followed by field names:"
msgstr ""
"为了让 ``py::array_t`` 与结构化（记录）类型一起工作，首先需要注册该类型的内存布局。"
"这可以通过 ``PYBIND11_NUMPY_DTYPE`` 宏来完成，在插件定义代码中调用，它期望类型后面跟着字段名："

#: ../../advanced/pycpp/numpy.rst:228
msgid ""
"The structure should consist of fundamental arithmetic types, "
"``std::complex``, previously registered substructures, and arrays of any "
"of the above. Both C++ arrays and ``std::array`` are supported. While "
"there is a static assertion to prevent many types of unsupported "
"structures, it is still the user's responsibility to use only \"plain\" "
"structures that can be safely manipulated as raw memory without violating"
" invariants."
msgstr ""
"该结构应该由基本算术类型、``std::complex``、之前注册的子结构和上述任何类型的数组组成。"

#: ../../advanced/pycpp/numpy.rst:236
msgid "Vectorizing functions"
msgstr "向量化函数"

#: ../../advanced/pycpp/numpy.rst:238
msgid ""
"Suppose we want to bind a function with the following signature to Python"
" so that it can process arbitrary NumPy array arguments (vectors, "
"matrices, general N-D arrays) in addition to its normal arguments:"
msgstr ""
"假设想将具有以下签名的函数绑定到 Python，以便它除了处理普通参数外，还可以处理任意 NumPy 数组参数（向量、矩阵、一般的 N-D 数组）："

#: ../../advanced/pycpp/numpy.rst:246
msgid "After including the ``pybind11/numpy.h`` header, this is extremely simple:"
msgstr "在包含 ``pybind11/numpy.h`` 头之后，这是极其简单的："

#: ../../advanced/pycpp/numpy.rst:252
msgid ""
"Invoking the function like below causes 4 calls to be made to ``my_func``"
" with each of the array elements. The significant advantage of this "
"compared to solutions like ``numpy.vectorize()`` is that the loop over "
"the elements runs entirely on the C++ side and can be crunched down into "
"a tight, optimized loop by the compiler. The result is returned as a "
"NumPy array of type ``numpy.dtype.float64``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:266
msgid ""
"The scalar argument ``z`` is transparently replicated 4 times.  The input"
" arrays ``x`` and ``y`` are automatically converted into the right types "
"(they are of type  ``numpy.dtype.int64`` but need to be "
"``numpy.dtype.int32`` and ``numpy.dtype.float32``, respectively)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:273
msgid ""
"Only arithmetic, complex, and POD types passed by value or by ``const &``"
" reference are vectorized; all other arguments are passed through as-is. "
"Functions taking rvalue reference arguments cannot be vectorized."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:277
msgid ""
"In cases where the computation is too complicated to be reduced to "
"``vectorize``, it will be necessary to create and access the buffer "
"contents manually. The following snippet contains a complete example that"
" shows how this works (the code is somewhat contrived, since it could "
"have been done more simply using ``vectorize``)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:320
msgid ""
"The file :file:`tests/test_numpy_vectorize.cpp` contains a complete "
"example that demonstrates using :func:`vectorize` in more detail."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:324
msgid "Direct access"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:326
msgid ""
"For performance reasons, particularly when dealing with very large "
"arrays, it is often desirable to directly access array elements without "
"internal checking of dimensions and bounds on every access when indices "
"are known to be already valid.  To avoid such checks, the ``array`` class"
" and ``array_t<T>`` template class offer an unchecked proxy object that "
"can be used for this unchecked access through the ``unchecked<N>`` and "
"``mutable_unchecked<N>`` methods, where ``N`` gives the required "
"dimensionality of the array:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:353
msgid ""
"To obtain the proxy from an ``array`` object, you must specify both the "
"data type and number of dimensions as template arguments, such as ``auto "
"r = myarray.mutable_unchecked<float, 2>()``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:357
msgid ""
"If the number of dimensions is not known at compile time, you can omit "
"the dimensions template parameter (i.e. calling ``arr_t.unchecked()`` or "
"``arr.unchecked<T>()``.  This will give you a proxy object that works in "
"the same way, but results in less optimizable code and thus a small "
"efficiency loss in tight loops."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:363
msgid ""
"Note that the returned proxy object directly references the array's data,"
" and only reads its shape, strides, and writeable flag when constructed."
"  You must take care to ensure that the referenced array is not destroyed"
" or reshaped for the duration of the returned object, typically by "
"limiting the scope of the returned instance."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:369
msgid ""
"The returned proxy object supports some of the same methods as "
"``py::array`` so that it can be used as a drop-in replacement for some "
"existing, index-checked uses of ``py::array``:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:373
msgid "``.ndim()`` returns the number of dimensions"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:375
msgid ""
"``.data(1, 2, ...)`` and ``r.mutable_data(1, 2, ...)``` returns a pointer"
" to the ``const T`` or ``T`` data, respectively, at the given indices.  "
"The latter is only available to proxies obtained via "
"``a.mutable_unchecked()``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:379
msgid "``.itemsize()`` returns the size of an item in bytes, i.e. ``sizeof(T)``."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:381
msgid "``.ndim()`` returns the number of dimensions."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:383
msgid "``.shape(n)`` returns the size of dimension ``n``"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:385
msgid ""
"``.size()`` returns the total number of elements (i.e. the product of the"
" shapes)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:387
msgid ""
"``.nbytes()`` returns the number of bytes used by the referenced elements"
" (i.e. ``itemsize()`` times ``size()``)."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:392
msgid ""
"The file :file:`tests/test_numpy_array.cpp` contains additional examples "
"demonstrating the use of this feature."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:396
msgid "Ellipsis"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:398
msgid ""
"Python provides a convenient ``...`` ellipsis notation that is often used"
" to slice multidimensional arrays. For instance, the following snippet "
"extracts the middle dimensions of a tensor with the first and last index "
"set to zero."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:407
msgid ""
"The function ``py::ellipsis()`` function can be used to perform the same "
"operation on the C++ side:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:417
msgid "Memory view"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:419
msgid ""
"For a case when we simply want to provide a direct accessor to C/C++ "
"buffer without a concrete class object, we can return a ``memoryview`` "
"object. Suppose we wish to expose a ``memoryview`` for 2x4 uint8_t array,"
" we can do the following:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:438
msgid ""
"This approach is meant for providing a ``memoryview`` for a C/C++ buffer "
"not managed by Python. The user is responsible for managing the lifetime "
"of the buffer. Using a ``memoryview`` created in this way after deleting "
"the buffer in C++ side results in undefined behavior."
msgstr ""

#: ../../advanced/pycpp/numpy.rst:443
msgid ""
"We can also use ``memoryview::from_memory`` for a simple 1D contiguous "
"buffer:"
msgstr ""

#: ../../advanced/pycpp/numpy.rst:454
msgid "``memoryview::from_memory`` added."
msgstr ""

