# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-29 20:28+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../advanced/misc.rst:2
msgid "Miscellaneous"
msgstr ""

#: ../../advanced/misc.rst:7
msgid "General notes regarding convenience macros"
msgstr ""

#: ../../advanced/misc.rst:9
msgid ""
"pybind11 provides a few convenience macros such as "
":func:`PYBIND11_DECLARE_HOLDER_TYPE` and ``PYBIND11_OVERRIDE_*``. Since "
"these are \"just\" macros that are evaluated in the preprocessor (which "
"has no concept of types), they *will* get confused by commas in a "
"template argument; for example, consider:"
msgstr ""

#: ../../advanced/misc.rst:19
msgid ""
"The limitation of the C preprocessor interprets this as five arguments "
"(with new arguments beginning after each comma) rather than three.  To "
"get around this, there are two alternatives: you can use a type alias, or"
" you can wrap the type using the ``PYBIND11_TYPE`` macro:"
msgstr ""

#: ../../advanced/misc.rst:35
msgid ""
"The ``PYBIND11_MAKE_OPAQUE`` macro does *not* require the above "
"workarounds."
msgstr ""

#: ../../advanced/misc.rst:40
msgid "Global Interpreter Lock (GIL)"
msgstr ""

#: ../../advanced/misc.rst:42
msgid ""
"The Python C API dictates that the Global Interpreter Lock (GIL) must "
"always be held by the current thread to safely access Python objects. As "
"a result, when Python calls into C++ via pybind11 the GIL must be held, "
"and pybind11 will never implicitly release the GIL."
msgstr ""

#: ../../advanced/misc.rst:57
msgid ""
"pybind11 will ensure that the GIL is held when it knows that it is "
"calling Python code. For example, if a Python callback is passed to C++ "
"code via ``std::function``, when C++ code calls the function the built-in"
" wrapper will acquire the GIL before calling the Python callback. "
"Similarly, the ``PYBIND11_OVERRIDE`` family of macros will acquire the "
"GIL before calling back into Python."
msgstr ""

#: ../../advanced/misc.rst:64
msgid ""
"When writing C++ code that is called from other C++ code, if that code "
"accesses Python state, it must explicitly acquire and release the GIL."
msgstr ""

#: ../../advanced/misc.rst:67
msgid ""
"The classes :class:`gil_scoped_release` and :class:`gil_scoped_acquire` "
"can be used to acquire and release the global interpreter lock in the "
"body of a C++ function call. In this way, long-running C++ code can be "
"parallelized using multiple Python threads, **but great care must be "
"taken** when any :class:`gil_scoped_release` appear: if there is any way "
"that the C++ code can access Python objects, :class:`gil_scoped_acquire` "
"should be used to reacquire the GIL. Taking :ref:`overriding_virtuals` as"
" an example, this could be realized as follows (important changes "
"highlighted):"
msgstr ""

#: ../../advanced/misc.rst:113
msgid ""
"The ``call_go`` wrapper can also be simplified using the ``call_guard`` "
"policy (see :ref:`call_policies`) which yields the same result:"
msgstr ""

#: ../../advanced/misc.rst:122
msgid "Common Sources Of Global Interpreter Lock Errors"
msgstr ""

#: ../../advanced/misc.rst:124
msgid ""
"Failing to properly hold the Global Interpreter Lock (GIL) is one of the "
"more common sources of bugs within code that uses pybind11. If you are "
"running into GIL related errors, we highly recommend you consult the "
"following checklist."
msgstr ""

#: ../../advanced/misc.rst:129
msgid ""
"Do you have any global variables that are pybind11 objects or invoke "
"pybind11 functions in either their constructor or destructor? You are "
"generally not allowed to invoke any Python function in a global static "
"context. We recommend using lazy initialization and then intentionally "
"leaking at the end of the program."
msgstr ""

#: ../../advanced/misc.rst:134
msgid ""
"Do you have any pybind11 objects that are members of other C++ "
"structures? One commonly overlooked requirement is that pybind11 objects "
"have to increase their reference count whenever their copy constructor is"
" called. Thus, you need to be holding the GIL to invoke the copy "
"constructor of any C++ class that has a pybind11 member. This can "
"sometimes be very tricky to track for complicated programs Think "
"carefully when you make a pybind11 object a member in another struct."
msgstr ""

#: ../../advanced/misc.rst:141
msgid ""
"C++ destructors that invoke Python functions can be particularly "
"troublesome as destructors can sometimes get invoked in weird and "
"unexpected circumstances as a result of exceptions."
msgstr ""

#: ../../advanced/misc.rst:145
msgid ""
"You should try running your code in a debug build. That will enable "
"additional assertions within pybind11 that will throw exceptions on "
"certain GIL handling errors (reference counting operations)."
msgstr ""

#: ../../advanced/misc.rst:150
msgid "Binding sequence data types, iterators, the slicing protocol, etc."
msgstr ""

#: ../../advanced/misc.rst:152
msgid "Please refer to the supplemental example for details."
msgstr ""

#: ../../advanced/misc.rst:156
msgid ""
"The file :file:`tests/test_sequences_and_iterators.cpp` contains a "
"complete example that shows how to bind a sequence data type, including "
"length queries (``__len__``), iterators (``__iter__``), the slicing "
"protocol and other kinds of useful operations."
msgstr ""

#: ../../advanced/misc.rst:163
msgid "Partitioning code over multiple extension modules"
msgstr ""

#: ../../advanced/misc.rst:165
msgid ""
"It's straightforward to split binding code over multiple extension "
"modules, while referencing types that are declared elsewhere. Everything "
"\"just\" works without any special precautions. One exception to this "
"rule occurs when extending a type declared in another extension module. "
"Recall the basic example from Section :ref:`inheritance`."
msgstr ""

#: ../../advanced/misc.rst:181
msgid ""
"Suppose now that ``Pet`` bindings are defined in a module named "
"``basic``, whereas the ``Dog`` bindings are defined somewhere else. The "
"challenge is of course that the variable ``pet`` is not available anymore"
" though it is needed to indicate the inheritance relationship to the "
"constructor of ``class_<Dog>``. However, it can be acquired as follows:"
msgstr ""

#: ../../advanced/misc.rst:195
msgid ""
"Alternatively, you can specify the base class as a template parameter "
"option to ``class_``, which performs an automated lookup of the "
"corresponding Python type. Like the above code, however, this also "
"requires invoking the ``import`` function once to ensure that the "
"pybind11 binding code of the module ``basic`` has been executed:"
msgstr ""

#: ../../advanced/misc.rst:209
msgid "Naturally, both methods will fail when there are cyclic dependencies."
msgstr ""

#: ../../advanced/misc.rst:211
msgid ""
"Note that pybind11 code compiled with hidden-by-default symbol visibility"
" (e.g. via the command line flag ``-fvisibility=hidden`` on GCC/Clang), "
"which is required for proper pybind11 functionality, can interfere with "
"the ability to access types defined in another extension module.  Working"
" around this requires manually exporting types that are accessed by "
"multiple extension modules; pybind11 provides a macro to do just this:"
msgstr ""

#: ../../advanced/misc.rst:224
msgid ""
"Note also that it is possible (although would rarely be required) to "
"share arbitrary C++ objects between extension modules at runtime. "
"Internal library data is shared between modules using capsule machinery "
"[#f6]_ which can be also utilized for storing, modifying and accessing "
"user-defined data. Note that an extension module will \"see\" other "
"extensions' data if and only if they were built with the same pybind11 "
"version. Consider the following example:"
msgstr ""

#: ../../advanced/misc.rst:237
msgid ""
"If the above snippet was used in several separately compiled extension "
"modules, the first one to be imported would create a ``MyData`` instance "
"and associate a ``\"mydata\"`` key with a pointer to it. Extensions that "
"are imported later would be then able to access the data behind the same "
"pointer."
msgstr ""

#: ../../advanced/misc.rst:242
msgid "https://docs.python.org/3/extending/extending.html#using-capsules"
msgstr ""

#: ../../advanced/misc.rst:245
msgid "Module Destructors"
msgstr ""

#: ../../advanced/misc.rst:247
msgid ""
"pybind11 does not provide an explicit mechanism to invoke cleanup code at"
" module destruction time. In rare cases where such functionality is "
"required, it is possible to emulate it using Python capsules or weak "
"references with a destruction callback."
msgstr ""

#: ../../advanced/misc.rst:260
msgid ""
"This approach has the potential downside that instances of classes "
"exposed within the module may still be alive when the cleanup callback is"
" invoked (whether this is acceptable will generally depend on the "
"application)."
msgstr ""

#: ../../advanced/misc.rst:264
msgid ""
"Alternatively, the capsule may also be stashed within a type object, "
"which ensures that it not called before all instances of that type have "
"been collected:"
msgstr ""

#: ../../advanced/misc.rst:273
msgid ""
"Both approaches also expose a potentially dangerous ``_cleanup`` "
"attribute in Python, which may be undesirable from an API standpoint (a "
"premature explicit call from Python might lead to undefined behavior). "
"Yet another approach that avoids this issue involves weak reference with "
"a cleanup callback:"
msgstr ""

#: ../../advanced/misc.rst:294
msgid ""
"PyPy does not garbage collect objects when the interpreter exits. An "
"alternative approach (which also works on CPython) is to use the "
":py:mod:`atexit` module [#f7]_, for example:"
msgstr ""

#: ../../advanced/misc.rst:305
msgid "https://docs.python.org/3/library/atexit.html"
msgstr ""

#: ../../advanced/misc.rst:309
msgid "Generating documentation using Sphinx"
msgstr ""

#: ../../advanced/misc.rst:311
msgid ""
"Sphinx [#f4]_ has the ability to inspect the signatures and documentation"
" strings in pybind11-based extension modules to automatically generate "
"beautiful documentation in a variety formats. The python_example "
"repository [#f5]_ contains a simple example repository which uses this "
"approach."
msgstr ""

#: ../../advanced/misc.rst:316
msgid ""
"There are two potential gotchas when using this approach: first, make "
"sure that the resulting strings do not contain any :kbd:`TAB` characters,"
" which break the docstring parsing routines. You may want to use C++11 "
"raw string literals, which are convenient for multi-line comments. "
"Conveniently, any excess indentation will be automatically be removed by "
"Sphinx. However, for this to work, it is important that all lines are "
"indented consistently, i.e.:"
msgstr ""

#: ../../advanced/misc.rst:340
msgid ""
"By default, pybind11 automatically generates and prepends a signature to "
"the docstring of a function registered with ``module_::def()`` and "
"``class_::def()``. Sometimes this behavior is not desirable, because you "
"want to provide your own signature or remove the docstring completely to "
"exclude the function from the Sphinx documentation. The class ``options``"
" allows you to selectively suppress auto-generated signatures:"
msgstr ""

#: ../../advanced/misc.rst:355
msgid ""
"pybind11 also appends all members of an enum to the resulting enum "
"docstring. This default behavior can be disabled by using the "
"``disable_enum_members_docstring()`` function of the ``options`` class."
msgstr ""

#: ../../advanced/misc.rst:359
msgid ""
"With ``disable_user_defined_docstrings()`` all user defined docstrings of"
" ``module_::def()``, ``class_::def()`` and ``enum_()`` are disabled, but "
"the function signatures and enum members are included in the docstring, "
"unless they are disabled separately."
msgstr ""

#: ../../advanced/misc.rst:364
msgid ""
"Note that changes to the settings affect only function bindings created "
"during the lifetime of the ``options`` instance. When it goes out of "
"scope at the end of the module's init function, the default settings are "
"restored to prevent unwanted side effects."
msgstr ""

#: ../../advanced/misc.rst:368
msgid "http://www.sphinx-doc.org"
msgstr ""

#: ../../advanced/misc.rst:369
msgid "http://github.com/pybind/python_example"
msgstr ""

#: ../../advanced/misc.rst:374
msgid "Avoiding C++ types in docstrings"
msgstr ""

#: ../../advanced/misc.rst:376
msgid ""
"Docstrings are generated at the time of the declaration, e.g. when "
"``.def(...)`` is called. At this point parameter and return types should "
"be known to pybind11. If a custom type is not exposed yet through a "
"``py::class_`` constructor or a custom type caster, its C++ type name "
"will be used instead to generate the signature in the docstring:"
msgstr ""

#: ../../advanced/misc.rst:388
msgid ""
"This limitation can be circumvented by ensuring that C++ classes are "
"registered with pybind11 before they are used as a parameter or return "
"type of a function:"
msgstr ""

#~ msgid ""
#~ "When calling a C++ function from "
#~ "Python, the GIL is always held. "
#~ "The classes :class:`gil_scoped_release` and "
#~ ":class:`gil_scoped_acquire` can be used to "
#~ "acquire and release the global "
#~ "interpreter lock in the body of a"
#~ " C++ function call. In this way, "
#~ "long-running C++ code can be "
#~ "parallelized using multiple Python threads."
#~ " Taking :ref:`overriding_virtuals` as an "
#~ "example, this could be realized as "
#~ "follows (important changes highlighted):"
#~ msgstr ""

