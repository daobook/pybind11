# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../advanced/cast/strings.rst:2
msgid "Strings, bytes and Unicode conversions"
msgstr ""

#: ../../advanced/cast/strings.rst:5
msgid "Passing Python strings to C++"
msgstr ""

#: ../../advanced/cast/strings.rst:7
msgid ""
"When a Python ``str`` is passed from Python to a C++ function that "
"accepts ``std::string`` or ``char *`` as arguments, pybind11 will encode "
"the Python string to UTF-8. All Python ``str`` can be encoded in UTF-8, "
"so this operation does not fail."
msgstr ""

#: ../../advanced/cast/strings.rst:12
msgid ""
"The C++ language is encoding agnostic. It is the responsibility of the "
"programmer to track encodings. It's often easiest to simply `use UTF-8 "
"everywhere <http://utf8everywhere.org/>`_."
msgstr ""

#: ../../advanced/cast/strings.rst:43
msgid ""
"Some terminal emulators do not support UTF-8 or emoji fonts and may not "
"display the example above correctly."
msgstr ""

#: ../../advanced/cast/strings.rst:46
msgid ""
"The results are the same whether the C++ function accepts arguments by "
"value or reference, and whether or not ``const`` is used."
msgstr ""

#: ../../advanced/cast/strings.rst:50
msgid "Passing bytes to C++"
msgstr ""

#: ../../advanced/cast/strings.rst:52
msgid ""
"A Python ``bytes`` object will be passed to C++ functions that accept "
"``std::string`` or ``char*`` *without* conversion.  In order to make a "
"function *only* accept ``bytes`` (and not ``str``), declare it as taking "
"a ``py::bytes`` argument."
msgstr ""

#: ../../advanced/cast/strings.rst:59
msgid "Returning C++ strings to Python"
msgstr ""

#: ../../advanced/cast/strings.rst:61
msgid ""
"When a C++ function returns a ``std::string`` or ``char*`` to a Python "
"caller, **pybind11 will assume that the string is valid UTF-8** and will "
"decode it to a native Python ``str``, using the same API as Python uses "
"to perform ``bytes.decode('utf-8')``. If this implicit conversion fails, "
"pybind11 will raise a ``UnicodeDecodeError``."
msgstr ""

#: ../../advanced/cast/strings.rst:81
msgid ""
"Because UTF-8 is inclusive of pure ASCII, there is never any issue with "
"returning a pure ASCII string to Python. If there is any possibility that"
" the string is not pure ASCII, it is necessary to ensure the encoding is "
"valid UTF-8."
msgstr ""

#: ../../advanced/cast/strings.rst:88
msgid ""
"Implicit conversion assumes that a returned ``char *`` is null-"
"terminated. If there is no null terminator a buffer overrun will occur."
msgstr ""

#: ../../advanced/cast/strings.rst:92
msgid "Explicit conversions"
msgstr ""

#: ../../advanced/cast/strings.rst:94
msgid ""
"If some C++ code constructs a ``std::string`` that is not a UTF-8 string,"
" one can perform a explicit conversion and return a ``py::str`` object. "
"Explicit conversion has the same overhead as implicit conversion."
msgstr ""

#: ../../advanced/cast/strings.rst:114
msgid ""
"The `Python C API <https://docs.python.org/3/c-api/unicode.html#built-in-"
"codecs>`_ provides several built-in codecs."
msgstr ""

#: ../../advanced/cast/strings.rst:119
msgid ""
"One could also use a third party encoding library such as libiconv to "
"transcode to UTF-8."
msgstr ""

#: ../../advanced/cast/strings.rst:123
msgid "Return C++ strings without conversion"
msgstr ""

#: ../../advanced/cast/strings.rst:125
msgid ""
"If the data in a C++ ``std::string`` does not represent text and should "
"be returned to Python as ``bytes``, then one can return the data as a "
"``py::bytes`` object."
msgstr ""

#: ../../advanced/cast/strings.rst:144
msgid ""
"Note the asymmetry: pybind11 will convert ``bytes`` to ``std::string`` "
"without encoding, but cannot convert ``std::string`` back to ``bytes`` "
"implicitly."
msgstr ""

#: ../../advanced/cast/strings.rst:165
msgid "Wide character strings"
msgstr ""

#: ../../advanced/cast/strings.rst:167
msgid ""
"When a Python ``str`` is passed to a C++ function expecting "
"``std::wstring``, ``wchar_t*``, ``std::u16string`` or ``std::u32string``,"
" the ``str`` will be encoded to UTF-16 or UTF-32 depending on how the C++"
" compiler implements each type, in the platform's native endianness. When"
" strings of these types are returned, they are assumed to contain valid "
"UTF-16 or UTF-32, and will be decoded to Python ``str``."
msgstr ""

#: ../../advanced/cast/strings.rst:199
msgid ""
"Strings in multibyte encodings such as Shift-JIS must transcoded to a "
"UTF-8/16/32 before being returned to Python."
msgstr ""

#: ../../advanced/cast/strings.rst:204
msgid "Character literals"
msgstr ""

#: ../../advanced/cast/strings.rst:206
msgid ""
"C++ functions that accept character literals as input will receive the "
"first character of a Python ``str`` as their input. If the string is "
"longer than one Unicode character, trailing characters will be ignored."
msgstr ""

#: ../../advanced/cast/strings.rst:210
msgid ""
"When a character literal is returned from C++ (such as a ``char`` or a "
"``wchar_t``), it will be converted to a ``str`` that represents the "
"single character."
msgstr ""

#: ../../advanced/cast/strings.rst:224
msgid ""
"While C++ will cast integers to character types (``char c = 0x65;``), "
"pybind11 does not convert Python integers to characters implicitly. The "
"Python function ``chr()`` can be used to convert integers to characters."
msgstr ""

#: ../../advanced/cast/strings.rst:236
msgid ""
"If the desire is to work with an 8-bit integer, use ``int8_t`` or "
"``uint8_t`` as the argument type."
msgstr ""

#: ../../advanced/cast/strings.rst:240
msgid "Grapheme clusters"
msgstr ""

#: ../../advanced/cast/strings.rst:242
msgid ""
"A single grapheme may be represented by two or more Unicode characters. "
"For example 'Ã©' is usually represented as U+00E9 but can also be "
"expressed as the combining character sequence U+0065 U+0301 (that is, the"
" letter 'e' followed by a combining acute accent). The combining "
"character will be lost if the two-character sequence is passed as an "
"argument, even though it renders as a single grapheme."
msgstr ""

#: ../../advanced/cast/strings.rst:265
msgid ""
"Normalizing combining characters before passing the character literal to "
"C++ may resolve *some* of these issues:"
msgstr ""

#: ../../advanced/cast/strings.rst:273
msgid ""
"In some languages (Thai for example), there are `graphemes that cannot be"
" expressed as a single Unicode code point "
"<http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries>`_, so "
"there is no way to capture them in a C++ character type."
msgstr ""

#: ../../advanced/cast/strings.rst:280
msgid "C++17 string views"
msgstr ""

#: ../../advanced/cast/strings.rst:282
msgid ""
"C++17 string views are automatically supported when compiling in C++17 "
"mode. They follow the same rules for encoding and decoding as the "
"corresponding STL string type (for example, a ``std::u16string_view`` "
"argument will be passed UTF-16-encoded data, and a returned "
"``std::string_view`` will be decoded as UTF-8)."
msgstr ""

#: ../../advanced/cast/strings.rst:289
msgid "References"
msgstr ""

#: ../../advanced/cast/strings.rst:291
msgid ""
"`The Absolute Minimum Every Software Developer Absolutely, Positively "
"Must Know About Unicode and Character Sets (No Excuses!) "
"<https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-"
"software-developer-absolutely-positively-must-know-about-unicode-and-"
"character-sets-no-excuses/>`_"
msgstr ""

#: ../../advanced/cast/strings.rst:292
msgid ""
"`C++ - Using STL Strings at Win32 API Boundaries "
"<https://msdn.microsoft.com/en-ca/magazine/mt238407.aspx>`_"
msgstr ""

