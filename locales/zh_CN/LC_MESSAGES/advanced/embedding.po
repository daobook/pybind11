# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../advanced/embedding.rst:4
msgid "Embedding the interpreter"
msgstr ""

#: ../../advanced/embedding.rst:6
msgid ""
"While pybind11 is mainly focused on extending Python using C++, it's also"
" possible to do the reverse: embed the Python interpreter into a C++ "
"program. All of the other documentation pages still apply here, so refer "
"to them for general pybind11 usage. This section will cover a few extra "
"things required for embedding."
msgstr ""

#: ../../advanced/embedding.rst:13
msgid "Getting started"
msgstr ""

#: ../../advanced/embedding.rst:15
msgid ""
"A basic executable with an embedded interpreter can be created with just "
"a few lines of CMake and the ``pybind11::embed`` target, as shown below. "
"For more information, see :doc:`/compiling`."
msgstr ""

#: ../../advanced/embedding.rst:29
msgid "The essential structure of the ``main.cpp`` file looks like this:"
msgstr ""

#: ../../advanced/embedding.rst:42
msgid ""
"The interpreter must be initialized before using any Python API, which "
"includes all the functions and classes in pybind11. The RAII guard class "
"``scoped_interpreter`` takes care of the interpreter lifetime. After the "
"guard is destroyed, the interpreter shuts down and clears its memory. No "
"Python functions can be called after this."
msgstr ""

#: ../../advanced/embedding.rst:48
msgid "Executing Python code"
msgstr ""

#: ../../advanced/embedding.rst:50
msgid ""
"There are a few different ways to run Python code. One option is to use "
"``eval``, ``exec`` or ``eval_file``, as explained in :ref:`eval`. Here is"
" a quick example in the context of an executable with an embedded "
"interpreter:"
msgstr ""

#: ../../advanced/embedding.rst:69
msgid ""
"Alternatively, similar results can be achieved using pybind11's API (see "
":doc:`/advanced/pycpp/index` for more details)."
msgstr ""

#: ../../advanced/embedding.rst:86
msgid "The two approaches can also be combined:"
msgstr ""

#: ../../advanced/embedding.rst:109
msgid "Importing modules"
msgstr ""

#: ../../advanced/embedding.rst:111
msgid "Python modules can be imported using ``module_::import()``:"
msgstr ""

#: ../../advanced/embedding.rst:118
msgid ""
"For convenience, the current working directory is included in "
"``sys.path`` when embedding the interpreter. This makes it easy to import"
" local Python files:"
msgstr ""

#: ../../advanced/embedding.rst:137
msgid ""
"Modules can be reloaded using ``module_::reload()`` if the source is "
"modified e.g. by an external process. This can be useful in scenarios "
"where the application imports a user defined data processing script which"
" needs to be updated after changes by the user. Note that this function "
"does not reload modules recursively."
msgstr ""

#: ../../advanced/embedding.rst:145
msgid "Adding embedded modules"
msgstr ""

#: ../../advanced/embedding.rst:147
msgid ""
"Embedded binary modules can be added using the "
"``PYBIND11_EMBEDDED_MODULE`` macro. Note that the definition must be "
"placed at global scope. They can be imported like any other module."
msgstr ""

#: ../../advanced/embedding.rst:171
msgid ""
"Unlike extension modules where only a single binary module can be "
"created, on the embedded side an unlimited number of modules can be added"
" using multiple ``PYBIND11_EMBEDDED_MODULE`` definitions (as long as they"
" have unique names)."
msgstr ""

#: ../../advanced/embedding.rst:175
msgid ""
"These modules are added to Python's list of builtins, so they can also be"
" imported in pure Python files loaded by the interpreter. Everything "
"interacts naturally:"
msgstr ""

#: ../../advanced/embedding.rst:217
msgid "Interpreter lifetime"
msgstr ""

#: ../../advanced/embedding.rst:219
msgid ""
"The Python interpreter shuts down when ``scoped_interpreter`` is "
"destroyed. After this, creating a new instance will restart the "
"interpreter. Alternatively, the ``initialize_interpreter`` / "
"``finalize_interpreter`` pair of functions can be used to directly set "
"the state at any time."
msgstr ""

#: ../../advanced/embedding.rst:224
msgid ""
"Modules created with pybind11 can be safely re-initialized after the "
"interpreter has been restarted. However, this may not apply to third-"
"party extension modules. The issue is that Python itself cannot "
"completely unload extension modules and there are several caveats with "
"regard to interpreter restarting. In short, not all memory may be freed, "
"either due to Python reference cycles or user-created global data. All "
"the details can be found in the CPython documentation."
msgstr ""

#: ../../advanced/embedding.rst:233
msgid ""
"Creating two concurrent ``scoped_interpreter`` guards is a fatal error. "
"So is calling ``initialize_interpreter`` for a second time after the "
"interpreter has already been initialized."
msgstr ""

#: ../../advanced/embedding.rst:237
msgid ""
"Do not use the raw CPython API functions ``Py_Initialize`` and "
"``Py_Finalize`` as these do not properly handle the lifetime of "
"pybind11's internal data."
msgstr ""

#: ../../advanced/embedding.rst:243
msgid "Sub-interpreter support"
msgstr ""

#: ../../advanced/embedding.rst:245
msgid ""
"Creating multiple copies of ``scoped_interpreter`` is not possible "
"because it represents the main Python interpreter. Sub-interpreters are "
"something different and they do permit the existence of multiple "
"interpreters. This is an advanced feature of the CPython API and should "
"be handled with care. pybind11 does not currently offer a C++ interface "
"for sub-interpreters, so refer to the CPython documentation for all the "
"details regarding this feature."
msgstr ""

#: ../../advanced/embedding.rst:252
msgid ""
"We'll just mention a couple of caveats the sub-interpreters support in "
"pybind11:"
msgstr ""

#: ../../advanced/embedding.rst:254
msgid ""
"Sub-interpreters will not receive independent copies of embedded modules."
" Instead, these are shared and modifications in one interpreter may be "
"reflected in another."
msgstr ""

#: ../../advanced/embedding.rst:258
msgid ""
"Managing multiple threads, multiple interpreters and the GIL can be "
"challenging and there are several caveats here, even within the pure "
"CPython API (please refer to the Python docs for details). As for "
"pybind11, keep in mind that ``gil_scoped_release`` and "
"``gil_scoped_acquire`` do not take sub-interpreters into account."
msgstr ""

