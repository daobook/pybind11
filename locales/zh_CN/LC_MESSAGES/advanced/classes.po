# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Wenzel Jakob
# This file is distributed under the same license as the pybind11 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pybind11 2.10.0.dev1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-31 12:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.1\n"

#: ../../advanced/classes.rst:2
msgid "Classes"
msgstr ""

#: ../../advanced/classes.rst:4
msgid ""
"This section presents advanced binding code for classes and it is assumed"
" that you are already familiar with the basics from :doc:`/classes`."
msgstr ""

#: ../../advanced/classes.rst:10
msgid "Overriding virtual functions in Python"
msgstr ""

#: ../../advanced/classes.rst:12
msgid ""
"Suppose that a C++ class or interface has a virtual function that we'd "
"like to override from within Python (we'll focus on the class ``Animal``;"
" ``Dog`` is given as a specific example of how one would do this with "
"traditional C++ code)."
msgstr ""

#: ../../advanced/classes.rst:35
msgid ""
"Let's also suppose that we are given a plain function which calls the "
"function ``go()`` on an arbitrary ``Animal`` instance."
msgstr ""

#: ../../advanced/classes.rst:44
msgid "Normally, the binding code for these classes would look as follows:"
msgstr ""

#: ../../advanced/classes.rst:58
msgid ""
"However, these bindings are impossible to extend: ``Animal`` is not "
"constructible, and we clearly require some kind of \"trampoline\" that "
"redirects virtual calls back to Python."
msgstr ""

#: ../../advanced/classes.rst:62
msgid ""
"Defining a new type of ``Animal`` from within Python is possible but "
"requires a helper class that is defined as follows:"
msgstr ""

#: ../../advanced/classes.rst:83
msgid ""
"The macro :c:macro:`PYBIND11_OVERRIDE_PURE` should be used for pure "
"virtual functions, and :c:macro:`PYBIND11_OVERRIDE` should be used for "
"functions which have a default implementation.  There are also two "
"alternate macros :c:macro:`PYBIND11_OVERRIDE_PURE_NAME` and "
":c:macro:`PYBIND11_OVERRIDE_NAME` which take a string-valued name "
"argument between the *Parent class* and *Name of the function* slots, "
"which defines the name of function in Python. This is required when the "
"C++ and Python versions of the function have different names, e.g.  "
"``operator()`` vs ``__call__``."
msgstr ""

#: ../../advanced/classes.rst:92
msgid "The binding code also needs a few minor adaptations (highlighted):"
msgstr ""

#: ../../advanced/classes.rst:108
msgid ""
"Importantly, pybind11 is made aware of the trampoline helper class by "
"specifying it as an extra template argument to :class:`class_`. (This can"
" also be combined with other template arguments such as a custom holder "
"type; the order of template types does not matter).  Following this, we "
"are able to define a constructor as usual."
msgstr ""

#: ../../advanced/classes.rst:114
msgid ""
"Bindings should be made against the actual class, not the trampoline "
"helper class."
msgstr ""

#: ../../advanced/classes.rst:123
msgid ""
"Note, however, that the above is sufficient for allowing python classes "
"to extend ``Animal``, but not ``Dog``: see :ref:`virtual_and_inheritance`"
" for the necessary steps required to providing proper overriding support "
"for inherited classes."
msgstr ""

#: ../../advanced/classes.rst:128
msgid ""
"The Python session below shows how to override ``Animal::go`` and invoke "
"it via a virtual method call."
msgstr ""

#: ../../advanced/classes.rst:145
msgid ""
"If you are defining a custom constructor in a derived Python class, you "
"*must* ensure that you explicitly call the bound C++ constructor using "
"``__init__``, *regardless* of whether it is a default constructor or not."
" Otherwise, the memory for the C++ portion of the instance will be left "
"uninitialized, which will generally leave the C++ instance in an invalid "
"state and cause undefined behavior if the C++ instance is subsequently "
"used."
msgstr ""

#: ../../advanced/classes.rst:152
msgid ""
"The default pybind11 metaclass will throw a ``TypeError`` when it detects"
" that ``__init__`` was not called by a derived class."
msgstr ""

#: ../../advanced/classes.rst:156
msgid "Here is an example:"
msgstr ""

#: ../../advanced/classes.rst:168
msgid ""
"Note that a direct ``__init__`` constructor *should be called*, and "
"``super()`` should not be used. For simple cases of linear inheritance, "
"``super()`` may work, but once you begin mixing Python and C++ multiple "
"inheritance, things will fall apart due to differences between Python's "
"MRO and C++'s mechanisms."
msgstr ""

#: ../../advanced/classes.rst:174
msgid "Please take a look at the :ref:`macro_notes` before using this feature."
msgstr ""

#: ../../advanced/classes.rst:178
msgid ""
"When the overridden type returns a reference or pointer to a type that "
"pybind11 converts from Python (for example, numeric values, std::string, "
"and other built-in value-converting types), there are some limitations to"
" be aware of:"
msgstr ""

#: ../../advanced/classes.rst:183
msgid ""
"because in these cases there is no C++ variable to reference (the value "
"is stored in the referenced Python variable), pybind11 provides one in "
"the PYBIND11_OVERRIDE macros (when needed) with static storage duration. "
"Note that this means that invoking the overridden method on *any* "
"instance will change the referenced value stored in *all* instances of "
"that type."
msgstr ""

#: ../../advanced/classes.rst:190
msgid ""
"Attempts to modify a non-const reference will not have the desired "
"effect: it will change only the static cache variable, but this change "
"will not propagate to underlying Python instance, and the change will be "
"replaced the next time the override is invoked."
msgstr ""

#: ../../advanced/classes.rst:197
msgid ""
"The :c:macro:`PYBIND11_OVERRIDE` and accompanying macros used to be "
"called ``PYBIND11_OVERLOAD`` up until pybind11 v2.5.0, and "
":func:`get_override` used to be called ``get_overload``. This naming was "
"corrected and the older macro and function names may soon be deprecated, "
"in order to reduce confusion with overloaded functions and methods and "
"``py::overload_cast`` (see :ref:`classes`)."
msgstr ""

#: ../../advanced/classes.rst:206
msgid ""
"The file :file:`tests/test_virtual_functions.cpp` contains a complete "
"example that demonstrates how to override virtual functions using "
"pybind11 in more detail."
msgstr ""

#: ../../advanced/classes.rst:213
msgid "Combining virtual functions and inheritance"
msgstr ""

#: ../../advanced/classes.rst:215
msgid ""
"When combining virtual methods with inheritance, you need to be sure to "
"provide an override for each method for which you want to allow overrides"
" from derived python classes.  For example, suppose we extend the above "
"``Animal``/``Dog`` example as follows:"
msgstr ""

#: ../../advanced/classes.rst:238
msgid ""
"then the trampoline class for ``Animal`` must, as described in the "
"previous section, override ``go()`` and ``name()``, but in order to allow"
" python code to inherit properly from ``Dog``, we also need a trampoline "
"class for ``Dog`` that overrides both the added ``bark()`` method *and* "
"the ``go()`` and ``name()`` methods inherited from ``Animal`` (even "
"though ``Dog`` doesn't directly override the ``name()`` method):"
msgstr ""

#: ../../advanced/classes.rst:263
msgid ""
"Note the trailing commas in the ``PYBIND11_OVERRIDE`` calls to ``name()``"
" and ``bark()``. These are needed to portably implement a trampoline for "
"a function that does not take any arguments. For functions that take a "
"nonzero number of arguments, the trailing comma must be omitted."
msgstr ""

#: ../../advanced/classes.rst:268
msgid ""
"A registered class derived from a pybind11-registered class with virtual "
"methods requires a similar trampoline class, *even if* it doesn't "
"explicitly declare or override any virtual methods itself:"
msgstr ""

#: ../../advanced/classes.rst:283
msgid ""
"There is, however, a technique that can be used to avoid this duplication"
" (which can be especially helpful for a base class with several virtual "
"methods).  The technique involves using template trampoline classes, as "
"follows:"
msgstr ""

#: ../../advanced/classes.rst:304
msgid ""
"This technique has the advantage of requiring just one trampoline method "
"to be declared per virtual method and pure virtual method override.  It "
"does, however, require the compiler to generate at least as many methods "
"(and possibly more, if both pure virtual and overridden pure virtual "
"methods are exposed, as above)."
msgstr ""

#: ../../advanced/classes.rst:310
msgid "The classes are then registered with pybind11 using:"
msgstr ""

#: ../../advanced/classes.rst:319
msgid ""
"Note that ``Husky`` did not require a dedicated trampoline template class"
" at all, since it neither declares any new virtual methods nor provides "
"any pure virtual method implementations."
msgstr ""

#: ../../advanced/classes.rst:323
msgid ""
"With either the repeated-virtuals or templated trampoline methods in "
"place, you can now create a python class that inherits from ``Dog``:"
msgstr ""

#: ../../advanced/classes.rst:334
msgid ""
"See the file :file:`tests/test_virtual_functions.cpp` for complete "
"examples using both the duplication and templated trampoline approaches."
msgstr ""

#: ../../advanced/classes.rst:340
msgid "Extended trampoline class functionality"
msgstr ""

#: ../../advanced/classes.rst:345
msgid "Forced trampoline class initialisation"
msgstr ""

#: ../../advanced/classes.rst:346
msgid ""
"The trampoline classes described in the previous sections are, by "
"default, only initialized when needed.  More specifically, they are "
"initialized when a python class actually inherits from a registered type "
"(instead of merely creating an instance of the registered type), or when "
"a registered constructor is only valid for the trampoline class but not "
"the registered class.  This is primarily for performance reasons: when "
"the trampoline class is not needed for anything except virtual method "
"dispatching, not initializing the trampoline class improves performance "
"by avoiding needing to do a run-time check to see if the inheriting "
"python instance has an overridden method."
msgstr ""

#: ../../advanced/classes.rst:356
msgid ""
"Sometimes, however, it is useful to always initialize a trampoline class "
"as an intermediate class that does more than just handle virtual method "
"dispatching. For example, such a class might perform extra class "
"initialization, extra destruction operations, and might define new "
"members and methods to enable a more python-like interface to a class."
msgstr ""

#: ../../advanced/classes.rst:362
msgid ""
"In order to tell pybind11 that it should *always* initialize the "
"trampoline class when creating new instances of a type, the class "
"constructors should be declared using ``py::init_alias<Args, ...>()`` "
"instead of the usual ``py::init<Args, ...>()``.  This forces construction"
" via the trampoline class, ensuring member initialization and (eventual) "
"destruction."
msgstr ""

#: ../../advanced/classes.rst:370
msgid ""
"See the file :file:`tests/test_virtual_functions.cpp` for complete "
"examples showing both normal and forced trampoline instantiation."
msgstr ""

#: ../../advanced/classes.rst:374
msgid "Different method signatures"
msgstr ""

#: ../../advanced/classes.rst:375
msgid ""
"The macro's introduced in :ref:`overriding_virtuals` cover most of the "
"standard use cases when exposing C++ classes to Python. Sometimes it is "
"hard or unwieldy to create a direct one-on-one mapping between the "
"arguments and method return type."
msgstr ""

#: ../../advanced/classes.rst:380
msgid ""
"An example would be when the C++ signature contains output arguments "
"using references (See also :ref:`faq_reference_arguments`). Another way "
"of solving this is to use the method body of the trampoline class to do "
"conversions to the input and return of the Python method."
msgstr ""

#: ../../advanced/classes.rst:385
msgid ""
"The main building block to do so is the :func:`get_override`, this "
"function allows retrieving a method implemented in Python from within the"
" trampoline's methods. Consider for example a C++ method which has the "
"signature ``bool myMethod(int32_t& value)``, where the return indicates "
"whether something should be done with the ``value``. This can be made "
"convenient on the Python side by allowing the Python function to return "
"``None`` or an ``int``:"
msgstr ""

#: ../../advanced/classes.rst:415
msgid "Custom constructors"
msgstr ""

#: ../../advanced/classes.rst:417
msgid ""
"The syntax for binding constructors was previously introduced, but it "
"only works when a constructor of the appropriate arguments actually "
"exists on the C++ side.  To extend this to more general cases, pybind11 "
"makes it possible to bind factory functions as constructors. For example,"
" suppose you have a class like this:"
msgstr ""

#: ../../advanced/classes.rst:436
msgid ""
"While it is possible to create a straightforward binding of the static "
"``create`` method, it may sometimes be preferable to expose it as a "
"constructor on the Python side. This can be accomplished by calling "
"``.def(py::init(...))`` with the function reference returning the new "
"instance passed as an argument. It is also possible to use this approach "
"to bind a function returning a new instance by raw pointer or by the "
"holder (e.g. ``std::unique_ptr``)."
msgstr ""

#: ../../advanced/classes.rst:443
msgid "The following example shows the different approaches:"
msgstr ""

#: ../../advanced/classes.rst:473
msgid ""
"When the constructor is invoked from Python, pybind11 will call the "
"factory function and store the resulting C++ instance in the Python "
"instance."
msgstr ""

#: ../../advanced/classes.rst:476
msgid ""
"When combining factory functions constructors with :ref:`virtual function"
" trampolines <overriding_virtuals>` there are two approaches.  The first "
"is to add a constructor to the alias class that takes a base value by "
"rvalue-reference.  If such a constructor is available, it will be used to"
" construct an alias instance from the value returned by the factory "
"function. The second option is to provide two factory functions to "
"``py::init()``: the first will be invoked when no alias class is required"
" (i.e. when the class is being used but not inherited from in Python), "
"and the second will be invoked when an alias is required."
msgstr ""

#: ../../advanced/classes.rst:486
msgid ""
"You can also specify a single factory function that always returns an "
"alias instance: this will result in behaviour similar to "
"``py::init_alias<...>()``, as described in the :ref:`extended trampoline "
"class documentation <extended_aliases>`."
msgstr ""

#: ../../advanced/classes.rst:491
msgid ""
"The following example shows the different factory approaches for a class "
"with an alias:"
msgstr ""

#: ../../advanced/classes.rst:519
msgid "Brace initialization"
msgstr ""

#: ../../advanced/classes.rst:521
msgid ""
"``pybind11::init<>`` internally uses C++11 brace initialization to call "
"the constructor of the target class. This means that it can be used to "
"bind *implicit* constructors as well:"
msgstr ""

#: ../../advanced/classes.rst:537
msgid ""
"Note that brace initialization preferentially invokes constructor "
"overloads taking a ``std::initializer_list``. In the rare event that this"
" causes an issue, you can work around it by using ``py::init(...)`` with "
"a lambda function that constructs the new object as desired."
msgstr ""

#: ../../advanced/classes.rst:545
msgid "Non-public destructors"
msgstr ""

#: ../../advanced/classes.rst:547
msgid ""
"If a class has a private or protected destructor (as might e.g. be the "
"case in a singleton pattern), a compile error will occur when creating "
"bindings via pybind11. The underlying issue is that the "
"``std::unique_ptr`` holder type that is responsible for managing the "
"lifetime of instances will reference the destructor even if no "
"deallocations ever take place. In order to expose classes with private or"
" protected destructors, it is possible to override the holder type via a "
"holder type argument to ``class_``. Pybind11 provides a helper class "
"``py::nodelete`` that disables any destructor invocations. In this case, "
"it is crucial that instances are deallocated on the C++ side to avoid "
"memory leaks."
msgstr ""

#: ../../advanced/classes.rst:574
msgid "Destructors that call Python"
msgstr ""

#: ../../advanced/classes.rst:576
msgid ""
"If a Python function is invoked from a C++ destructor, an exception may "
"be thrown of type :class:`error_already_set`. If this error is thrown out"
" of a class destructor, ``std::terminate()`` will be called, terminating "
"the process. Class destructors must catch all exceptions of type "
":class:`error_already_set` to discard the Python exception using "
":func:`error_already_set::discard_as_unraisable`."
msgstr ""

#: ../../advanced/classes.rst:582
msgid ""
"Every Python function should be treated as *possibly throwing*. When a "
"Python generator stops yielding items, Python will throw a "
"``StopIteration`` exception, which can pass though C++ destructors if the"
" generator's stack frame holds the last reference to C++ objects."
msgstr ""

#: ../../advanced/classes.rst:587
msgid ""
"For more information, see :ref:`the documentation on exceptions "
"<unraisable_exceptions>`."
msgstr ""

#: ../../advanced/classes.rst:607
msgid "pybind11 does not support C++ destructors marked ``noexcept(false)``."
msgstr ""

#: ../../advanced/classes.rst:614
msgid "Implicit conversions"
msgstr ""

#: ../../advanced/classes.rst:616
msgid ""
"Suppose that instances of two types ``A`` and ``B`` are used in a "
"project, and that an ``A`` can easily be converted into an instance of "
"type ``B`` (examples of this could be a fixed and an arbitrary precision "
"number type)."
msgstr ""

#: ../../advanced/classes.rst:633
msgid ""
"To invoke the function ``func`` using a variable ``a`` containing an "
"``A`` instance, we'd have to write ``func(B(a))`` in Python. On the other"
" hand, C++ will automatically apply an implicit type conversion, which "
"makes it possible to directly write ``func(a)``."
msgstr ""

#: ../../advanced/classes.rst:638
msgid ""
"In this situation (i.e. where ``B`` has a constructor that converts from "
"``A``), the following statement enables similar implicit conversions on "
"the Python side:"
msgstr ""

#: ../../advanced/classes.rst:648
msgid ""
"Implicit conversions from ``A`` to ``B`` only work when ``B`` is a custom"
" data type that is exposed to Python via pybind11."
msgstr ""

#: ../../advanced/classes.rst:651
msgid ""
"To prevent runaway recursion, implicit conversions are non-reentrant: an "
"implicit conversion invoked as part of another implicit conversion of the"
" same type (i.e. from ``A`` to ``B``) will fail."
msgstr ""

#: ../../advanced/classes.rst:658
msgid "Static properties"
msgstr ""

#: ../../advanced/classes.rst:660
msgid ""
"The section on :ref:`properties` discussed the creation of instance "
"properties that are implemented in terms of C++ getters and setters."
msgstr ""

#: ../../advanced/classes.rst:663
msgid ""
"Static properties can also be created in a similar way to expose getters "
"and setters of static class attributes. Note that the implicit ``self`` "
"argument also exists in this case and is used to pass the Python ``type``"
" subclass instance. This parameter will often not be needed by the C++ "
"side, and the following example illustrates how to instantiate a lambda "
"getter function that ignores it:"
msgstr ""

#: ../../advanced/classes.rst:676
msgid "Operator overloading"
msgstr ""

#: ../../advanced/classes.rst:678
msgid ""
"Suppose that we're given the following ``Vector2`` class with a vector "
"addition and scalar multiplication operation, all implemented using "
"overloaded operators in C++."
msgstr ""

#: ../../advanced/classes.rst:704
msgid ""
"The following snippet shows how the above operators can be conveniently "
"exposed to Python."
msgstr ""

#: ../../advanced/classes.rst:723
msgid "Note that a line like"
msgstr ""

#: ../../advanced/classes.rst:729
msgid "is really just short hand notation for"
msgstr ""

#: ../../advanced/classes.rst:737
msgid ""
"This can be useful for exposing additional operators that don't exist on "
"the C++ side, or to perform other types of customization. The "
"``py::is_operator`` flag marker is needed to inform pybind11 that this is"
" an operator, which returns ``NotImplemented`` when invoked with "
"incompatible arguments rather than throwing a type error."
msgstr ""

#: ../../advanced/classes.rst:745
msgid ""
"To use the more convenient ``py::self`` notation, the additional header "
"file :file:`pybind11/operators.h` must be included."
msgstr ""

#: ../../advanced/classes.rst:750
msgid ""
"The file :file:`tests/test_operator_overloading.cpp` contains a complete "
"example that demonstrates how to work with overloaded operators in more "
"detail."
msgstr ""

#: ../../advanced/classes.rst:757
msgid "Pickling support"
msgstr ""

#: ../../advanced/classes.rst:759
msgid ""
"Python's ``pickle`` module provides a powerful facility to serialize and "
"de-serialize a Python object graph into a binary data stream. To pickle "
"and unpickle C++ classes using pybind11, a ``py::pickle()`` definition "
"must be provided. Suppose the class in question has the following "
"signature:"
msgstr ""

#: ../../advanced/classes.rst:778
msgid ""
"Pickling support in Python is enabled by defining the ``__setstate__`` "
"and ``__getstate__`` methods [#f3]_. For pybind11 classes, use "
"``py::pickle()`` to bind these two functions:"
msgstr ""

#: ../../advanced/classes.rst:808
msgid ""
"The ``__setstate__`` part of the ``py::pickle()`` definition follows the "
"same rules as the single-argument version of ``py::init()``. The return "
"type can be a value, pointer or holder type. See "
":ref:`custom_constructors` for details."
msgstr ""

#: ../../advanced/classes.rst:812
msgid "An instance can now be pickled as follows:"
msgstr ""

#: ../../advanced/classes.rst:824
msgid ""
"If given, the second argument to ``dumps`` must be 2 or larger - 0 and 1 "
"are not supported. Newer versions are also fine; for instance, specify "
"``-1`` to always use the latest available version. Beware: failure to "
"follow these instructions will cause important pybind11 memory allocation"
" routines to be skipped during unpickling, which will likely lead to "
"memory corruption and/or segmentation faults. Python defaults to version "
"3 (Python 3-3.7) and version 4 for Python 3.8+."
msgstr ""

#: ../../advanced/classes.rst:834
msgid ""
"The file :file:`tests/test_pickling.cpp` contains a complete example that"
" demonstrates how to pickle and unpickle types using pybind11 in more "
"detail."
msgstr ""

#: ../../advanced/classes.rst:838
msgid "http://docs.python.org/3/library/pickle.html#pickling-class-instances"
msgstr ""

#: ../../advanced/classes.rst:841
msgid "Deepcopy support"
msgstr ""

#: ../../advanced/classes.rst:843
msgid ""
"Python normally uses references in assignments. Sometimes a real copy is "
"needed to prevent changing all copies. The ``copy`` module [#f5]_ "
"provides these capabilities."
msgstr ""

#: ../../advanced/classes.rst:847
msgid ""
"A class with pickle support is automatically also (deep)copy compatible. "
"However, performance can be improved by adding custom ``__copy__`` and "
"``__deepcopy__`` methods."
msgstr ""

#: ../../advanced/classes.rst:851
msgid ""
"For simple classes (deep)copy can be enabled by using the copy "
"constructor, which should look as follows:"
msgstr ""

#: ../../advanced/classes.rst:866
msgid "Dynamic attributes will not be copied in this example."
msgstr ""

#: ../../advanced/classes.rst:868
msgid "https://docs.python.org/3/library/copy.html"
msgstr ""

#: ../../advanced/classes.rst:871
msgid "Multiple Inheritance"
msgstr ""

#: ../../advanced/classes.rst:873
msgid ""
"pybind11 can create bindings for types that derive from multiple base "
"types (aka. *multiple inheritance*). To do so, specify all bases in the "
"template arguments of the ``class_`` declaration:"
msgstr ""

#: ../../advanced/classes.rst:882
msgid ""
"The base types can be specified in arbitrary order, and they can even be "
"interspersed with alias types and holder types (discussed earlier in this"
" document)---pybind11 will automatically find out which is which. The "
"only requirement is that the first template argument is the type to be "
"declared."
msgstr ""

#: ../../advanced/classes.rst:887
msgid ""
"It is also permitted to inherit multiply from exported C++ classes in "
"Python, as well as inheriting from multiple Python and/or "
"pybind11-exported classes."
msgstr ""

#: ../../advanced/classes.rst:890
msgid "There is one caveat regarding the implementation of this feature:"
msgstr ""

#: ../../advanced/classes.rst:892
msgid ""
"When only one base type is specified for a C++ type that actually has "
"multiple bases, pybind11 will assume that it does not participate in "
"multiple inheritance, which can lead to undefined behavior. In such "
"cases, add the tag ``multiple_inheritance`` to the class constructor:"
msgstr ""

#: ../../advanced/classes.rst:901
msgid ""
"The tag is redundant and does not need to be specified when multiple base"
" types are listed."
msgstr ""

#: ../../advanced/classes.rst:907
msgid "Module-local class bindings"
msgstr ""

#: ../../advanced/classes.rst:909
msgid ""
"When creating a binding for a class, pybind11 by default makes that "
"binding \"global\" across modules.  What this means is that a type "
"defined in one module can be returned from any module resulting in the "
"same Python type.  For example, this allows the following:"
msgstr ""

#: ../../advanced/classes.rst:935
msgid ""
"When writing binding code for a library, this is usually desirable: this "
"allows, for example, splitting up a complex library into multiple Python "
"modules."
msgstr ""

#: ../../advanced/classes.rst:939
msgid ""
"In some cases, however, this can cause conflicts.  For example, suppose "
"two unrelated modules make use of an external C++ library and each "
"provide custom bindings for one of that library's classes.  This will "
"result in an error when a Python program attempts to import both modules "
"(directly or indirectly) because of conflicting definitions on the "
"external type:"
msgstr ""

#: ../../advanced/classes.rst:977
msgid ""
"To get around this, you can tell pybind11 to keep the external class "
"binding localized to the module by passing the ``py::module_local()`` "
"attribute into the ``py::class_`` constructor:"
msgstr ""

#: ../../advanced/classes.rst:993
msgid ""
"This makes the Python-side ``dogs.Pet`` and ``cats.Pet`` into distinct "
"classes, avoiding the conflict and allowing both modules to be loaded.  "
"C++ code in the ``dogs`` module that casts or returns a ``Pet`` instance "
"will result in a ``dogs.Pet`` Python instance, while C++ code in the "
"``cats`` module will result in a ``cats.Pet`` Python instance."
msgstr ""

#: ../../advanced/classes.rst:999
msgid ""
"This does come with two caveats, however: First, external modules cannot "
"return or cast a ``Pet`` instance to Python (unless they also provide "
"their own local bindings).  Second, from the Python point of view they "
"are two distinct classes."
msgstr ""

#: ../../advanced/classes.rst:1003
msgid ""
"Note that the locality only applies in the C++ -> Python direction.  When"
" passing such a ``py::module_local`` type into a C++ function, the "
"module-local classes are still considered.  This means that if the "
"following function is added to any module (including but not limited to "
"the ``cats`` and ``dogs`` modules above) it will be callable with either "
"a ``dogs.Pet`` or ``cats.Pet`` argument:"
msgstr ""

#: ../../advanced/classes.rst:1014
msgid ""
"For example, suppose the above function is added to each of ``cats.cpp``,"
" ``dogs.cpp`` and ``frogs.cpp`` (where ``frogs.cpp`` is some other module"
" that does *not* bind ``Pets`` at all)."
msgstr ""

#: ../../advanced/classes.rst:1027
msgid ""
"It is possible to use ``py::module_local()`` registrations in one module "
"even if another module registers the same type globally: within the "
"module with the module-local definition, all C++ instances will be cast "
"to the associated bound Python type.  In other modules any such values "
"are converted to the global Python type created elsewhere."
msgstr ""

#: ../../advanced/classes.rst:1035
msgid ""
"STL bindings (as provided via the optional :file:`pybind11/stl_bind.h` "
"header) apply ``py::module_local`` by default when the bound type might "
"conflict with other modules; see :ref:`stl_bind` for details."
msgstr ""

#: ../../advanced/classes.rst:1041
msgid ""
"The localization of the bound types is actually tied to the shared object"
" or binary generated by the compiler/linker.  For typical modules created"
" with ``PYBIND11_MODULE()``, this distinction is not significant.  It is "
"possible, however, when :ref:`embedding` to embed multiple modules in the"
" same binary (see :ref:`embedding_modules`).  In such a case, the "
"localization will apply across all embedded modules within the same "
"binary."
msgstr ""

#: ../../advanced/classes.rst:1050
msgid ""
"The file :file:`tests/test_local_bindings.cpp` contains additional "
"examples that demonstrate how ``py::module_local()`` works."
msgstr ""

#: ../../advanced/classes.rst:1054
msgid "Binding protected member functions"
msgstr ""

#: ../../advanced/classes.rst:1056
msgid ""
"It's normally not possible to expose ``protected`` member functions to "
"Python:"
msgstr ""

#: ../../advanced/classes.rst:1068
msgid ""
"On one hand, this is good because non-``public`` members aren't meant to "
"be accessed from the outside. But we may want to make use of "
"``protected`` functions in derived Python classes."
msgstr ""

#: ../../advanced/classes.rst:1072
msgid "The following pattern makes this possible:"
msgstr ""

#: ../../advanced/classes.rst:1089
msgid ""
"This works because ``&Publicist::foo`` is exactly the same function as "
"``&A::foo`` (same signature and address), just with a different access "
"modifier. The only purpose of the ``Publicist`` helper class is to make "
"the function name ``public``."
msgstr ""

#: ../../advanced/classes.rst:1094
msgid ""
"If the intent is to expose ``protected`` ``virtual`` functions which can "
"be overridden in Python, the publicist pattern can be combined with the "
"previously described trampoline:"
msgstr ""

#: ../../advanced/classes.rst:1122
msgid "Binding final classes"
msgstr ""

#: ../../advanced/classes.rst:1124
msgid ""
"Some classes may not be appropriate to inherit from. In C++11, classes "
"can use the ``final`` specifier to ensure that a class cannot be "
"inherited from. The ``py::is_final`` attribute can be used to ensure that"
" Python classes cannot inherit from a specified type. The underlying C++ "
"type does not need to be declared final."
msgstr ""

#: ../../advanced/classes.rst:1136
msgid ""
"When you try to inherit from such a class in Python, you will now get "
"this error:"
msgstr ""

#: ../../advanced/classes.rst:1146
msgid "This attribute is currently ignored on PyPy"
msgstr ""

#: ../../advanced/classes.rst:1151
msgid "Binding classes with template parameters"
msgstr ""

#: ../../advanced/classes.rst:1153
msgid ""
"pybind11 can also wrap classes that have template parameters. Consider "
"these classes:"
msgstr ""

#: ../../advanced/classes.rst:1166
msgid ""
"C++ templates may only be instantiated at compile time, so pybind11 can "
"only wrap instantiated templated classes. You cannot wrap a non-"
"instantiated template:"
msgstr ""

#: ../../advanced/classes.rst:1175
msgid ""
"You must explicitly specify each template/type combination that you want "
"to wrap separately."
msgstr ""

#: ../../advanced/classes.rst:1188
msgid ""
"If your class methods have template parameters you can wrap those as "
"well, but once again each instantiation must be explicitly specified:"
msgstr ""

#: ../../advanced/classes.rst:1203
msgid "Custom automatic downcasters"
msgstr ""

#: ../../advanced/classes.rst:1205
msgid ""
"As explained in :ref:`inheritance`, pybind11 comes with built-in "
"understanding of the dynamic type of polymorphic objects in C++; that is,"
" returning a Pet to Python produces a Python object that knows it's "
"wrapping a Dog, if Pet has virtual methods and pybind11 knows about Dog "
"and this Pet is in fact a Dog. Sometimes, you might want to provide this "
"automatic downcasting behavior when creating bindings for a class "
"hierarchy that does not use standard C++ polymorphism, such as LLVM "
"[#f4]_. As long as there's some way to determine at runtime whether a "
"downcast is safe, you can proceed by specializing the "
"``pybind11::polymorphic_type_hook`` template:"
msgstr ""

#: ../../advanced/classes.rst:1244
msgid ""
"When pybind11 wants to convert a C++ pointer of type ``Base*`` to a "
"Python object, it calls ``polymorphic_type_hook<Base>::get()`` to "
"determine if a downcast is possible. The ``get()`` function should use "
"whatever runtime information is available to determine if its ``src`` "
"parameter is in fact an instance of some class ``Derived`` that inherits "
"from ``Base``. If it finds such a ``Derived``, it sets ``type = "
"&typeid(Derived)`` and returns a pointer to the ``Derived`` object that "
"contains ``src``. Otherwise, it just returns ``src``, leaving ``type`` at"
" its default value of nullptr. If you set ``type`` to a type that "
"pybind11 doesn't know about, no downcasting will occur, and the original "
"``src`` pointer will be used with its static type ``Base*``."
msgstr ""

#: ../../advanced/classes.rst:1257
msgid ""
"It is critical that the returned pointer and ``type`` argument of "
"``get()`` agree with each other: if ``type`` is set to something non-"
"null, the returned pointer must point to the start of an object whose "
"type is ``type``. If the hierarchy being exposed uses only single "
"inheritance, a simple ``return src;`` will achieve this just fine, but in"
" the general case, you must cast ``src`` to the appropriate derived-class"
" pointer (e.g. using ``static_cast<Derived>(src)``) before allowing it to"
" be returned as a ``void*``."
msgstr ""

#: ../../advanced/classes.rst:1267
msgid "https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html"
msgstr ""

#: ../../advanced/classes.rst:1271
msgid ""
"pybind11's standard support for downcasting objects whose types have "
"virtual methods is implemented using ``polymorphic_type_hook`` too, using"
" the standard C++ ability to determine the most-derived type of a "
"polymorphic object using ``typeid()`` and to cast a base pointer to that "
"most-derived type (even if you don't know what it is) using "
"``dynamic_cast<void*>``."
msgstr ""

#: ../../advanced/classes.rst:1280
msgid ""
"The file :file:`tests/test_tagbased_polymorphic.cpp` contains a more "
"complete example, including a demonstration of how to provide automatic "
"downcasting for an entire class hierarchy without writing one get() "
"function for each class."
msgstr ""

#: ../../advanced/classes.rst:1286
msgid "Accessing the type object"
msgstr ""

#: ../../advanced/classes.rst:1288
msgid ""
"You can get the type object from a C++ class that has already been "
"registered using:"
msgstr ""

#: ../../advanced/classes.rst:1294
msgid ""
"You can directly use ``py::type::of(ob)`` to get the type object from any"
" python object, just like ``type(ob)`` in Python."
msgstr ""

#: ../../advanced/classes.rst:1299
msgid ""
"Other types, like ``py::type::of<int>()``, do not work, see :ref:`type-"
"conversions`."
msgstr ""

#: ../../advanced/classes.rst:1304
msgid "Custom type setup"
msgstr ""

#: ../../advanced/classes.rst:1306
msgid ""
"For advanced use cases, such as enabling garbage collection support, you "
"may wish to directly manipulate the ``PyHeapTypeObject`` corresponding to"
" a ``py::class_`` definition."
msgstr ""

#: ../../advanced/classes.rst:1310
msgid "You can do that using ``py::custom_type_setup``:"
msgstr ""

